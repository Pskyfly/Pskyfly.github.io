<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Springboot注解 | 天航的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Spring注解驱动开发官方文档：https:&#x2F;&#x2F;docs.spring.io&#x2F;spring-boot&#x2F;docs&#x2F;current&#x2F;reference&#x2F;html&#x2F; IOC容器@Configuration和@Bean1234567@Configurationpublic class TestConfig &amp;#123;    @Bean(&quot;pet&quot;)    Pet pet01()&amp;#">
<meta property="og:type" content="article">
<meta property="og:title" content="Springboot注解">
<meta property="og:url" content="http://thgg.github.io/2022/11/30/Springboot%E6%B3%A8%E8%A7%A3/index.html">
<meta property="og:site_name" content="天航的博客">
<meta property="og:description" content="Spring注解驱动开发官方文档：https:&#x2F;&#x2F;docs.spring.io&#x2F;spring-boot&#x2F;docs&#x2F;current&#x2F;reference&#x2F;html&#x2F; IOC容器@Configuration和@Bean1234567@Configurationpublic class TestConfig &amp;#123;    @Bean(&quot;pet&quot;)    Pet pet01()&amp;#">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/beff8c142e35a5232d3b1aa3c2a2a1fd.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/887ee291698ec5ad12eba05e1aaedb93.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/9865bf7ed075b674b017b4ca4761c438.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/1a85f7c4f61ef84015db8399c2dc5c26.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/52e55156c3151266c703521baa50894b.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/adb33ab5072d670e87b4db7711f0284f.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/b9336d67e0efc1224aa90450f017c8c0.png">
<meta property="article:published_time" content="2022-11-30T11:21:34.000Z">
<meta property="article:modified_time" content="2022-11-30T11:21:51.885Z">
<meta property="article:author" content="LTH">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/img_convert/beff8c142e35a5232d3b1aa3c2a2a1fd.png">
  
    <link rel="alternate" href="/atom.xml" title="天航的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">天航的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://thgg.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Springboot注解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/30/Springboot%E6%B3%A8%E8%A7%A3/" class="article-date">
  <time datetime="2022-11-30T11:21:34.000Z" itemprop="datePublished">2022-11-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Springboot注解
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Spring注解驱动开发"><a href="#Spring注解驱动开发" class="headerlink" title="Spring注解驱动开发"></a>Spring注解驱动开发</h1><p>官方文档：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/">https://docs.spring.io/spring-boot/docs/current/reference/html/</a></p>
<h2 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h2><h3 id="Configuration和-Bean"><a href="#Configuration和-Bean" class="headerlink" title="@Configuration和@Bean"></a>@Configuration和@Bean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(&quot;pet&quot;)</span></span><br><span class="line">    Pet <span class="title function_">pet01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pet</span>(<span class="string">&quot;LTH&quot;</span>,<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Configuration声明为配置类，作用等价于配置文件</p>
<p>@Bean用于向容器中注册bean，可以bean的id默认为方法名，也可以通过@Bean的value字段设置id</p>
<h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>这个注解用于配置包的扫描规则，需要作用于配置类上（@Configuration）</p>
<p>如果不设置value或者basePackage的值，则扫描路径默认是当前类所在的包及其子包</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;com.demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetOtherComponentConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@SpringBootApplication会默认扫描启动类所在包（com.demo2）的所有组件，其中的配置类可以扫描其他包(com.demo)下的组件</p>
<p>启动类本身也是一个配置类，任何下都会被扫描</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(Demo2Application.class, args);</span><br><span class="line">        String[] beanDefinitionNames = context.getBeanDefinitionNames();</span><br><span class="line">        Arrays.stream(beanDefinitionNames).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@ComponentScan带有注解@Repeatable(ComponentScans.class)，可以在一个配置类上加上多个@ComponentScan设置扫描路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Documented</span><br><span class="line">@Repeatable(ComponentScans.class)</span><br><span class="line">public @interface ComponentScan</span><br></pre></td></tr></table></figure>

<p>可以用includeFilters指定扫描路径下具体包含哪些组件，默认全部包含,所以要加上（useDefaultFilters = false）这个属性，includeFilters才能生效，excludeFilters用于在包含的组件中排除一些组件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">        value = &quot;com.demo.test&quot;,</span></span><br><span class="line"><span class="meta">        excludeFilters = &#123;</span></span><br><span class="line"><span class="meta">                @ComponentScan.Filter(type = FilterType.ANNOTATION,classes = &#123;Controller.class&#125;)</span></span><br><span class="line"><span class="meta">        &#125;,</span></span><br><span class="line"><span class="meta">        includeFilters = &#123;</span></span><br><span class="line"><span class="meta">                @ComponentScan.Filter(type = FilterType.ANNOTATION,classes = &#123;Controller.class&#125;)</span></span><br><span class="line"><span class="meta">        &#125;,</span></span><br><span class="line"><span class="meta">        useDefaultFilters = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetOtherComponentConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/img_convert/beff8c142e35a5232d3b1aa3c2a2a1fd.png" alt="image-20220513123912758"></p>
<p>自定义过滤规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceFilter</span> <span class="keyword">implements</span> <span class="title class_">TypeFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//类信息</span></span><br><span class="line">        <span class="type">ClassMetadata</span> <span class="variable">classMetadata</span> <span class="operator">=</span> metadataReader.getClassMetadata();</span><br><span class="line">        <span class="comment">//注解信息</span></span><br><span class="line">        <span class="type">AnnotationMetadata</span> <span class="variable">annotationMetadata</span> <span class="operator">=</span> metadataReader.getAnnotationMetadata();</span><br><span class="line">        <span class="comment">//资源文件所在的路径</span></span><br><span class="line">        <span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> metadataReader.getResource();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>excludeFilters：false表示不被筛除，true表示被筛除</p>
<p>includeFilters：false表示不被包含，true表示被包含</p>
<h3 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h3><p>设置bean的作用域（单实例还是多实例）</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/887ee291698ec5ad12eba05e1aaedb93.png" alt="image-20220513130139954"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetOtherComponentConfig</span> &#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> User <span class="title function_">user01</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;123&quot;</span>,<span class="number">12</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认单实例</p>
<p>prototype：使用时创建bean，容器启动时不创建bean</p>
<p>singleton：容器启动时创建bean，获取时从容器中获取</p>
<h3 id="Lazy"><a href="#Lazy" class="headerlink" title="@Lazy"></a>@Lazy</h3><p>懒加载单例bean（多实例没有lan）</p>
<p>在Spring容器启动的时候不创建bena，在获取这个bean的时候再创建这个bean，这个bean只会创建一次，第一次创建后后面获取bean就是从Spring容器中获取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetOtherComponentConfig</span> &#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@Lazy</span></span><br><span class="line">        <span class="keyword">public</span> User <span class="title function_">user01</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;123&quot;</span>,<span class="number">12</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Conditional条件装配"><a href="#Conditional条件装配" class="headerlink" title="@Conditional条件装配"></a>@Conditional条件装配</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetOtherComponentConfig</span> &#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@Conditional(LinuxCondition.class)</span></span><br><span class="line">        <span class="keyword">public</span> User <span class="title function_">user01</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;linux&quot;</span>,<span class="number">12</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@Conditional(WindowCondition.class)</span></span><br><span class="line">        <span class="keyword">public</span> User <span class="title function_">user02</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;windows&quot;</span>,<span class="number">12</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Conditional需要我们传入实现了Condition（org.springframework.context.annotation.Condition）接口的类，可以传入一个数组</p>
<p>然后根据这个接口中的matches方法的返回值来判断当前@Bean是否需要注入Spring容器中</p>
<p>matches返回true表示装配进Spring容器中，返回false表示不装配进Spring容器</p>
<p>下面两个类根据当前操作系统的类型来判断是否要装配进Spring容器中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinuxCondition</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class="line">        <span class="type">Environment</span> <span class="variable">environment</span> <span class="operator">=</span> context.getEnvironment();</span><br><span class="line">        <span class="type">String</span> <span class="variable">property</span> <span class="operator">=</span> environment.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(property!=<span class="literal">null</span>&amp;&amp;property.contains(<span class="string">&quot;Linux&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowCondition</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class="line">        <span class="type">Environment</span> <span class="variable">environment</span> <span class="operator">=</span> context.getEnvironment();</span><br><span class="line">        <span class="type">String</span> <span class="variable">property</span> <span class="operator">=</span> environment.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(property!=<span class="literal">null</span>&amp;&amp;property.contains(<span class="string">&quot;Window&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果输出window是那个bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationDemoApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(AnnotationDemoApplication.class, args);</span><br><span class="line">        context.getBeansOfType(User.class).forEach((k,v)-&gt;&#123;</span><br><span class="line">            System.out.println(k+<span class="string">&quot;:&quot;</span>+v);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果作用于方法上，则是对整个类进行条件装配，如果返回false，整个配置类都会失效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Conditional(LinuxCondition.class)</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.demo.test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetOtherComponentConfig</span> &#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@Conditional(LinuxCondition.class)</span></span><br><span class="line">        <span class="keyword">public</span> User <span class="title function_">user01</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;linux&quot;</span>,<span class="number">12</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@Conditional(WindowCondition.class)</span></span><br><span class="line">        <span class="keyword">public</span> User <span class="title function_">user02</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;windows&quot;</span>,<span class="number">12</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如当前是windows环境，因而这个配置类会失效，因而加了注解：@ComponentScan(“com.demo.test”)也不会得到其他包的组件</p>
<h3 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h3><p>注册组件的方式：</p>
<p>1.包扫描+组件注册注解（@Controller,@Service,@Repository,@Component）</p>
<p>2.配置类+@Bean注册bean</p>
<p>3.@import</p>
<p>4.使用Spring提供的FactoryBean（工厂bean）</p>
<h4 id="快速注册组件"><a href="#快速注册组件" class="headerlink" title="快速注册组件"></a>快速注册组件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123;User.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetOtherComponentConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册的组件id是这个类的全限定名：com.demo.test.pojo.User</p>
<p>如果已经有名为com.demo.test.pojo.User的组件（重复的类）则不再注册</p>
<h4 id="也可以传入一个实现了ImportSelector的类："><a href="#也可以传入一个实现了ImportSelector的类：" class="headerlink" title="也可以传入一个实现了ImportSelector的类："></a>也可以传入一个实现了ImportSelector的类：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;com.demo.test.pojo.User&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>importingClassMetadata是标注的类的元数据，注意这个方法不能返回null，否则会出现空指针异常</p>
<p>返回值是全限定名组成的数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(UserSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetOtherComponentConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在@Import中传入这个selector类时，就会根据数组中的全限定名创建bean</p>
<h4 id="传入实现了ImportBeanDefinitionRegistrar接口的类："><a href="#传入实现了ImportBeanDefinitionRegistrar接口的类：" class="headerlink" title="传入实现了ImportBeanDefinitionRegistrar接口的类："></a>传入实现了ImportBeanDefinitionRegistrar接口的类：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserBeanDefinition</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;uuser&quot;</span>,<span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(User.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于手动传入bean的定义注册组件（批量注册组件），用@Import引入这个类完成批量注册的功能</p>
<p>只能用@Import注解导入组件时才会注册组件，用@Bean或者@Component都不会注册组件</p>
<h3 id="工厂bean"><a href="#工厂bean" class="headerlink" title="工厂bean"></a>工厂bean</h3><p>注意工厂bean和bean工厂不同，工厂bean是一种特殊的bean，需要实现FactoryBean接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserBeanFactory</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;User&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;lth&quot;</span>,<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> User.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getObject    获取对象</p>
<p>getObjectType    获取对象的类型</p>
<p>isSingleton    设置是否是单实例对象，如果设置为true，每次获取的bean都是Spring容器中的bean，并且只会有一个。如果设置为false，则表示设置为多实例对象，每次调用getObject会生成新的对象。</p>
<p>通过之前说的三种方式向Spring容器中注册这个bean后，在获取这个bean的时候，会得到这个工厂bean生成的用getObject得到的bean</p>
<p>例如：（用@Import注入）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationDemoApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(AnnotationDemoApplication.class, args);</span><br><span class="line">        System.out.println(context.getBean(<span class="string">&quot;com.demo.annotationdemo.config.beanfactory.UserBeanFactory&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个得到的结果是User(username=lth, age=20)，证实了是用getObject方法得到的bean，想要获取工厂bean本身，需要在前面加上&amp;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationDemoApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(AnnotationDemoApplication.class, args);</span><br><span class="line">        System.out.println(context.getBean(<span class="string">&quot;&amp;com.demo.annotationdemo.config.beanfactory.UserBeanFactory&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到com.demo.annotationdemo.config.beanfactory.UserBeanFactory@2dc995f4</p>
<h3 id="Bean的创建和销毁"><a href="#Bean的创建和销毁" class="headerlink" title="Bean的创建和销毁"></a>Bean的创建和销毁</h3><h4 id="initMethod和destroyMethod"><a href="#initMethod和destroyMethod" class="headerlink" title="initMethod和destroyMethod"></a>initMethod和destroyMethod</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    String username;</span><br><span class="line">    Integer age;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以在需要加入容器的组件的bean对应的实体类创建创建（init）和销毁方法（destroy）（名字不一定要叫init和destroy）</p>
<p>然后在用@Bean注解向Spring容器中添加组件时，可以设置这个bean的创建和销毁方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetOtherComponentConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(value = &quot;user&quot;,initMethod = &quot;init&quot;,destroyMethod = &quot;destroy&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>initMethod：创建方法，在向Spring容器中添加这个组件和执行</p>
<p>destroyMethod：销毁方法，会在Spring容器关闭时执行（context.close()）</p>
<p>如果创建的对象是单实例的，则由Spring容器管理这些对象，容器启动时会调用initMethod方法，销毁时会调用destroyMethod</p>
<p>如果创建的对象是多实例的，则不会调用这两个方法（可以用@Scope设置是单实例还是多实例）</p>
<h4 id="InitializingBean和DisposableBean"><a href="#InitializingBean和DisposableBean" class="headerlink" title="InitializingBean和DisposableBean"></a>InitializingBean和DisposableBean</h4><p>可以让注册进Spring容器的bean实现这两个接口，完成bean的创建和销毁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span>, DisposableBean &#123;</span><br><span class="line">    String username;</span><br><span class="line">    Integer age;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodInit</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodInit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodDestroy</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodDestroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterPropertiesSet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这四个方法的执行顺序如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.afterPropertiesSet</span><br><span class="line">2.methodInit</span><br><span class="line">3.destroy</span><br><span class="line">4.methodDestroy</span><br></pre></td></tr></table></figure>

<h4 id="PostConstruct和-PreDestroy"><a href="#PostConstruct和-PreDestroy" class="headerlink" title="@PostConstruct和@PreDestroy"></a>@PostConstruct和@PreDestroy</h4><p>@PostConstruct标注的方法是在构造方法执行完后执行</p>
<p>@PreDestroy标注的方法是在bean销毁前执行</p>
<p>标注的方法都必须是无参数的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PostConstruct		构造方法执行完后执行</span><br><span class="line">afterPropertiesSet	属性设置完后执行</span><br><span class="line">methodInit			</span><br><span class="line">preDestroy</span><br><span class="line">destroy</span><br><span class="line">methodDestroy</span><br></pre></td></tr></table></figure>

<h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h3><p>以上Bean的创建和销毁都是作用于特定的bean中，而BeanPostProcessor则作用于所有的bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserPostProceccer</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postProcessBeforeInitialization:&quot;</span>+beanName);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postProcessAfterInitialization:&quot;</span>+beanName);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>postProcessBeforeInitialization    在创建完bean实例后，在所有初始化流程（initMethod，PostConstruct，afterPropertiesSet）之前执行，bean是刚创建好的bean，我们可以对其进行修改或者包装后返回。</p>
<p>postProcessAfterInitialization    是在初始化流程完成后（initMethod，PostConstruct，afterPropertiesSet）执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">构造方法</span><br><span class="line">postProcessBeforeInitialization:user</span><br><span class="line">PostConstruct</span><br><span class="line">afterPropertiesSet</span><br><span class="line">methodInit</span><br><span class="line">postProcessAfterInitialization:user</span><br><span class="line">使用bean</span><br><span class="line">preDestroy</span><br><span class="line">destroy</span><br><span class="line">methodDestroy</span><br></pre></td></tr></table></figure>

<p>所有的组件创建时（包括Spring自带的组件）都会执行这两个方法</p>
<h4 id="BeanPostProcessor作用原理"><a href="#BeanPostProcessor作用原理" class="headerlink" title="BeanPostProcessor作用原理"></a>BeanPostProcessor作用原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">initializeBean</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">		AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">			invokeAwareMethods(beanName, bean);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;, getAccessControlContext());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		invokeAwareMethods(beanName, bean);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">Object</span> <span class="variable">wrappedBean</span> <span class="operator">=</span> bean;</span><br><span class="line">	<span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">           <span class="comment">//执行上面设置的所有postProcessBeforeInitialization方法</span></span><br><span class="line">		wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//依次执行PostConstruct,afterPropertiesSet,methodInit方法</span></span><br><span class="line">		invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">				(mbd != <span class="literal">null</span> ? mbd.getResourceDescription() : <span class="literal">null</span>),</span><br><span class="line">				beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">           <span class="comment">//执行上面设置的所有postProcessAfterInitialization方法</span></span><br><span class="line">		wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用这个方法之前，还会先调用populateBean(beanName, mbd, instanceWrapper)方法进行属性赋值</p>
<h3 id="Spring对PostProcessor的使用"><a href="#Spring对PostProcessor的使用" class="headerlink" title="Spring对PostProcessor的使用"></a>Spring对PostProcessor的使用</h3><p>如果我们想在一个类中拿到IOC容器，可以让这个类实现ApplicationContextAware接口，其中的setApplicationContext方法就会把IOC容器的引用传进来，我们就可以把这个引用保存起来便于后续使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    ApplicationContext applicationContext;</span><br><span class="line">    String username;</span><br><span class="line">    Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationContext=applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用这个方法的组件就是ApplicationContextAwareProcessor</p>
<p>而之前标有@PostConstruct注解和@PreDestroy注解的方法的执行是通过InitDestroyAnnotationBeanPostProcessor这个PostProcessor来执行的（遍历所有bean的方法。执行其中带有@PostConstruct和@PreDestroy注解的方法）</p>
<p>包括我们使用@Autowire，@Async等注解，这些注解的处理都是通过实现PostProcessor接口来进行的</p>
<h3 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h3><p>可以作用于属性字段和方法参数上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;lth&quot;)</span></span><br><span class="line">    String username;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;5+15&#125;&quot;)</span></span><br><span class="line">    Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.可以直接设置值@Value(“lth”)</p>
<p>2.可以设置Spring表达式#{}来赋值@Value(“#{5+15}”)</p>
<p>3.可以使用${}获取配置文件的值@Value(${user.name})</p>
<p>（显然，这个会覆盖构造函数中设置的值）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;user01.name&#125;&quot;)</span></span><br><span class="line">    String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;user01.age&#125;&quot;)</span></span><br><span class="line">    Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h4><p>@PropertySource(“classpath:/myapplication.properties”) 可以使用这个注解加载额外的配置文件，只能加载properties配置文件，@PropertySource配置优先级高于默认配置文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:/myapplication.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserOtherComponentConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(&quot;user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zz&quot;</span>,<span class="number">11</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">myapplication.properties：</span></span><br><span class="line"><span class="comment">	user01.name=lth</span></span><br><span class="line"><span class="comment">	user01.age=22</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="AutoWired"><a href="#AutoWired" class="headerlink" title="@AutoWired"></a>@AutoWired</h3><p>假如当前容器中有多个User类型的对象，分别叫user01，user02</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.demo.test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserOtherComponentConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;user01&quot;</span>,<span class="number">11</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user02</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;user02&quot;</span>,<span class="number">22</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后使用@Autowired进行依赖注入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    User user01;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Autowired</p>
<p>先按照bean类型去找，如果有多个再按照bean的名称去找</p>
<p>1.如果容器中只有一个指定类型的bean，则装配这个唯一的bean</p>
<p>2.如果容器中有多个指定类型的bean，则根据装配字段的属性名称来装配（user01）</p>
<p>​    如果根据属性名称来寻找没有找到，则报错</p>
<p>​    如果容器中没有指定类型的bean，也会报错，如果不想让他报错，可以将require字段设置为false，这样在没有找到时会被设置为null而不会报错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">User user01; <span class="comment">//得到user01</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">User user01; <span class="comment">//得到user02</span></span><br><span class="line"><span class="meta">@AutoWired</span></span><br><span class="line">User user;	 <span class="comment">//报错</span></span><br></pre></td></tr></table></figure>

<h4 id="Primary"><a href="#Primary" class="headerlink" title="@Primary"></a>@Primary</h4><p>有多个可选的bean时，优先选择@Primary注解的bean（一个类型的bean只能有一个带有@Primary注解，否则会报错）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.demo.test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserOtherComponentConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;user01&quot;</span>,<span class="number">11</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user02</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;user02&quot;</span>,<span class="number">22</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    User user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时user会拿到user01</p>
<p>当有了@Primary注解后，就不再根据属性名user来查找bean了，而是直接拿到带有@Primary注解的bean，如果拿到多个@Primary注解的bean则报错</p>
<h4 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h4><p>@Qualifier用于指定查找的bean的id</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;user02&quot;)</span>        </span><br><span class="line">    User user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果属性注入字段带有@Qualifier注解，则装配这个字段的时候，如果找到多个指定类型的bean，直接找到id和@Qualifier注解的value值一样的bean，然后装配进来（@Primary注解失效）。</p>
<p>总结</p>
<p>当有多个相同类型的bean</p>
<p>1.有@Qualifier根据@Qualifier的value</p>
<p>2.有@Primary根据@Primary</p>
<p>3.都没有根据属性名</p>
<p>上述三条只能按照优先级选择一条规则，按照那个规则没有找到时都会报错</p>
<h3 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h3><p>@Resource有两个字段：name（bean的id），type（bean的类型）</p>
<h4 id="1-先按照name属性的值来找（如果没有设置则默认是属性名称）"><a href="#1-先按照name属性的值来找（如果没有设置则默认是属性名称）" class="headerlink" title="1.先按照name属性的值来找（如果没有设置则默认是属性名称）"></a>1.先按照name属性的值来找（如果没有设置则默认是属性名称）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;user02&quot;)</span></span><br><span class="line">    User user01;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里name设置了值，所以是按照user02来找而不是字段名称user01</p>
<p>如果根据名字找到了对应的bean，然后不管是什么类型都会尝试装配进来，如果类型兼容，则成功装配，如果类型不符合则报错</p>
<h4 id="2-如果根据name没有找到，则再根据type来找（如果没有设置type则默认是这个字段本身的类型）"><a href="#2-如果根据name没有找到，则再根据type来找（如果没有设置type则默认是这个字段本身的类型）" class="headerlink" title="2.如果根据name没有找到，则再根据type来找（如果没有设置type则默认是这个字段本身的类型）"></a>2.如果根据name没有找到，则再根据type来找（如果没有设置type则默认是这个字段本身的类型）</h4><p>如果根据type没有找到则报错，如果找到了进行下一步判断</p>
<h4 id="3-判断有无-Qualifier注解"><a href="#3-判断有无-Qualifier注解" class="headerlink" title="3.判断有无@Qualifier注解"></a>3.判断有无@Qualifier注解</h4><h5 id="1-如果有-Qualifier注解，则根据这个注解的值来找，如果找到了则装配，如果没有找到则报错"><a href="#1-如果有-Qualifier注解，则根据这个注解的值来找，如果找到了则装配，如果没有找到则报错" class="headerlink" title="1.如果有@Qualifier注解，则根据这个注解的值来找，如果找到了则装配，如果没有找到则报错"></a>1.如果有@Qualifier注解，则根据这个注解的值来找，如果找到了则装配，如果没有找到则报错</h5><p>假如有三个bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.demo.test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserOtherComponentConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;user01&quot;</span>,<span class="number">11</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user02</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;user02&quot;</span>,<span class="number">22</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user03</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;user03&quot;</span>,<span class="number">33</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用于装配的类是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource(type = User.class)</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;user02&quot;)</span></span><br><span class="line">    User user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会找到user02（根据user没有找到，再根据type=User.class来找，找到了三个：user01,user02,user03，然后再根据@Qualifier(“user02”)来找，找到user02进行装配）</p>
<p>而如果是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;user02&quot;)</span></span><br><span class="line">    User user03;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则会找到user03（没有设置name的值，name默认是就是字段的名称user03，并且优先级比@Qualifier要高）</p>
<h5 id="2-如果没有-Qualifier注解，则优先装配带有-Primary的bean"><a href="#2-如果没有-Qualifier注解，则优先装配带有-Primary的bean" class="headerlink" title="2.如果没有@Qualifier注解，则优先装配带有@Primary的bean"></a>2.如果没有@Qualifier注解，则优先装配带有@Primary的bean</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.demo.test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserOtherComponentConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;user01&quot;</span>,<span class="number">11</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user02</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;user02&quot;</span>,<span class="number">22</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样装配结果就是user01（type和属性类相同时可以不写）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource(type = User.class)</span></span><br><span class="line">    User user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有多个bean带有@Primary注解则会报错</p>
<h5 id="3-如果没有-Qualifier，也没有带有-Primary注解的bean，但是对应type的bean只有一个，则直接将这个bean装配进来"><a href="#3-如果没有-Qualifier，也没有带有-Primary注解的bean，但是对应type的bean只有一个，则直接将这个bean装配进来" class="headerlink" title="3.如果没有@Qualifier，也没有带有@Primary注解的bean，但是对应type的bean只有一个，则直接将这个bean装配进来"></a>3.如果没有@Qualifier，也没有带有@Primary注解的bean，但是对应type的bean只有一个，则直接将这个bean装配进来</h5><p>如果只找到了一个则直接装配进来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource(type = UserSon.class)</span></span><br><span class="line">    User user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.demo.test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserOtherComponentConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;user01&quot;</span>,<span class="number">11</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user02</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;user02&quot;</span>,<span class="number">22</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserSon <span class="title function_">userSon</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserSon</span>(<span class="string">&quot;son&quot;</span>,<span class="number">33</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里根据user没有找到，则根据type（UserSon是User的子类）来找，只找到了一个则直接装配进来，装配结果是userSon：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserController(user=User(username=son, age=33))</span><br></pre></td></tr></table></figure>

<p>如果根据type只找到了一个，并且没有@Qualifier注解，则直接装配进来。</p>
<h5 id="4-如果没有这两个注解，而且还有多个bean，则报错"><a href="#4-如果没有这两个注解，而且还有多个bean，则报错" class="headerlink" title="4.如果没有这两个注解，而且还有多个bean，则报错"></a>4.如果没有这两个注解，而且还有多个bean，则报错</h5><h3 id="Inject"><a href="#Inject" class="headerlink" title="@Inject"></a>@Inject</h3><p>功能和@Autowired一样，只是里面没有reqiure属性（所以被@Autowire完爆）</p>
<p>并且还需要引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>@Autowired注解，@Inject注解，@Resource注解，@Value注解都是使用ApplicationContextAwareProcessor来完成自动装配的</p>
<h3 id="Autowire作用于方法上"><a href="#Autowire作用于方法上" class="headerlink" title="@Autowire作用于方法上"></a>@Autowire作用于方法上</h3><h4 id="Autowire作用于构造器"><a href="#Autowire作用于构造器" class="headerlink" title="@Autowire作用于构造器"></a>@Autowire作用于构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    String username;</span><br><span class="line">    Integer age;</span><br><span class="line">    Pet pet;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    User(Pet pet)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造器：&quot;</span>+pet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用于构造器时，容器在创建这个组件的时候会为所有的方法参数按照@Autowired的规则自动装配（从Spring容器中找到对应的组件，并将引用赋值给对应的参数）</p>
<p>@Autowire除了自动装配的作用，还可以指定在创建组件时使用哪种构造器，如果只有一个构造器就使用那个唯一的构造器，使用的时候会完成自动装配，如果有多个参数，默认使用无参数构造器，如果我们想使用有参构造器可以在构造器上加上@Autowired注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    String username;</span><br><span class="line">    Integer age;</span><br><span class="line">    Pet pet;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    User(Pet pet)&#123;</span><br><span class="line">        <span class="built_in">this</span>.pet=pet;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造器：&quot;</span>+<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    User()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参构造器:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Tips：</span><br><span class="line">this.pet=pet;//this.pet代表的是对象的成员参数，后面那个pet代表的是方法参数</span><br><span class="line">属性参数Pet pet;作用域是整个类</span><br><span class="line">方法参数Pet pet的作用域是整个方法</span><br><span class="line">如果两者同名，作用域出现重叠，则以作用域小的参数优先(方法参数优先)，也就是用pet代表方法参数，this.pet代表属性参数</span><br></pre></td></tr></table></figure>

<p>加上@Autowired后，创建对象的时候就会调用有参构造器，不能有多个构造器同时标注@Autowire注解。如果只有一个构造器，@Autowired注解可以省略，省略后一样会完成自动装配</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    String username;</span><br><span class="line">    Integer age;</span><br><span class="line">    Pet pet;</span><br><span class="line"></span><br><span class="line">    User(Pet pet,String age)&#123;</span><br><span class="line">        <span class="built_in">this</span>.pet=pet;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造器：&quot;</span>+<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    User()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参构造器:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标注在方法参数表示只为这个字段进行自动装配，但是Spring会优先调用无参构造器，所以这里的有参构造器不会执行</p>
<p>如果删除无参构造器，或者在有参构造器上标注@Autowired注解，则会让Spring在创建bean的时候优先调用这个构造器，但是此时容器中没有age字段，所以会报错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    String username;</span><br><span class="line">    Integer age;</span><br><span class="line">    Pet pet;</span><br><span class="line"></span><br><span class="line">    User(<span class="meta">@Autowired</span> Pet pet, String age)&#123;</span><br><span class="line">        <span class="built_in">this</span>.pet=pet;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造器：&quot;</span>+<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不想让他报错，允许age以null的形式传进来，可以加上@Nullable注解（org.springframework.lang下的注解）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    String username;</span><br><span class="line">    Integer age;</span><br><span class="line">    Pet pet;</span><br><span class="line"></span><br><span class="line">    User(Pet pet,<span class="meta">@Nullable</span> String age)&#123;</span><br><span class="line">        <span class="built_in">this</span>.pet=pet;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造器：&quot;</span>+<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样如果容器中有age，则将age装配进来，如果容器中没有age则以null值传进来，而不会报错（相当于reqired=false）</p>
<h4 id="Autowired注解标注在方法参数上（无用）"><a href="#Autowired注解标注在方法参数上（无用）" class="headerlink" title="@Autowired注解标注在方法参数上（无用）"></a>@Autowired注解标注在方法参数上（无用）</h4><p>@Autowired作用于方法参数上没有什么作用，因为Spring调用这些方法时都会为所有的方法参数进行自动装配（相当于所有的方法参数上都默认带有@Autowired注解，并都进行了省略）</p>
<h4 id="作用于普通方法"><a href="#作用于普通方法" class="headerlink" title="作用于普通方法"></a>作用于普通方法</h4><p>如果作用于普通方法上，会在装配属性时调用这些方法，一样会为所有的方法参数进行自动装配</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    String username;</span><br><span class="line">    Integer age;</span><br><span class="line">    Pet pet;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">toSetPet</span><span class="params">(Pet pet)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.pet=pet;</span><br><span class="line">        System.out.println(<span class="string">&quot;toSetPet&quot;</span>+<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标注了@Bean注解的方法如果有参数，则也会自动装配</p>
<h3 id="Aware注入Spring底层组件"><a href="#Aware注入Spring底层组件" class="headerlink" title="Aware注入Spring底层组件"></a>Aware注入Spring底层组件</h3><p>如果我们想使用Spring底层的xxx组件，可以让当前类失效xxxAware接口，然后Spring在进行自动装配时，就会使用xxxAwareProccessor来执行对于Aware中对应的set方法来完成自动装配。</p>
<p>例如：</p>
<p>ApplicationContextAware    拿到IOC容器</p>
<p>BeanNameAware    拿到当前bean的名称</p>
<p>BeanFactoryAware    拿到Bean工厂</p>
<p>EmbeddedValueResolverAware    拿到表达式解析器解析Spring表达式（${}用于取出配置文件的值，#{}用于计算）</p>
<p>EnvironmentAware    拿到环境信息</p>
<p>ResourceLoaderAware    拿到配置文件的资源信息</p>
<p>ApplicationEventPublisherAware    拿到事件发布器</p>
<p>MessageSourceAware    拿到国际化组件</p>
<p>ApplicationStartupAware    开启器……</p>
<p>实现这些接口后会出现对应的set方法，通过set方法的方法参数拿到Spring的底层组件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">EmbeddedValueResolverAware</span> &#123;</span><br><span class="line">    String username;</span><br><span class="line">    Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmbeddedValueResolver</span><span class="params">(StringValueResolver resolver)</span> &#123;</span><br><span class="line">        System.out.println(resolver.resolveStringValue(<span class="string">&quot;$&#123;os.name&#125; #&#123;22+22&#125;&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：Windows 10 44</p>
<p>而使得这些接口生效则是依赖于ApplicationContextAwareProcessor，这个类实现了BeanPostProcessor，会在初始化前，调用这个bean所有对应接口的set方法，将我们需要的组将传进来。</p>
<p>postProcessBeforeInitialization方法会调用下面的invokeAwareInterfaces来实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">invokeAwareInterfaces</span><span class="params">(Object bean)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware) &#123;</span><br><span class="line">		((EnvironmentAware) bean).setEnvironment(<span class="built_in">this</span>.applicationContext.getEnvironment());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware) &#123;</span><br><span class="line">		((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(<span class="built_in">this</span>.embeddedValueResolver);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ResourceLoaderAware) &#123;</span><br><span class="line">		((ResourceLoaderAware) bean).setResourceLoader(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware) &#123;</span><br><span class="line">		((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MessageSourceAware) &#123;</span><br><span class="line">		((MessageSourceAware) bean).setMessageSource(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationStartupAware) &#123;</span><br><span class="line">		((ApplicationStartupAware) bean).setApplicationStartup(<span class="built_in">this</span>.applicationContext.getApplicationStartup());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</span><br><span class="line">		((ApplicationContextAware) bean).setApplicationContext(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法依次判断当前bean是否实现了指定的Aware接口，如果实现了则调用对应的set方法</p>
<h3 id="Profile条件装配"><a href="#Profile条件装配" class="headerlink" title="Profile条件装配"></a>Profile条件装配</h3><p>@PropertySource    加载额外的配置文件</p>
<p>从配置文件中获取数据的方法：</p>
<p>1.@Value(“${os.name}”)</p>
<p>2.使用Spring底层的值解析器EmbeddedValueResolver，获取方法是上一节讲的实现EmbeddedValueResolverAware接口</p>
<p>3.@ConfigurationProperties(“person”)    将配置文件中person下的值，按照字段名称装配进类中</p>
<p>@Profile可以标注在带有@Bean注解的方法上来选择性在Spring容器中注册bean</p>
<p>@Profile如果不设置value字段的值，则value字段的值默认是default，也就是默认环境下会使用的配置，不加@Profile则是在任何环境都会加载的bean。如果不激活任何环境也就是不设置spring.profiles.active的值（或者设置为default），这个值默认是default，默认会加载默认环境下的bean</p>
<p>条件装配的方法：</p>
<p>1.@Bean+@Profile（作用于@Configuration的类中的方法上）</p>
<p>2.添加组件的注解+@Profile（作用于类上）</p>
<p>然后用spring.profiles.active设置运行环境（也可以通过命令行参数来设置：两种方法-Dspring.profiles.active=xxx，–spring.profiles.active=xxx）</p>
<p>（具体内容可以看Springboot2那篇笔记）</p>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>通知方法：</p>
<p>1.前置通知(@Before)：方法运行之前运行</p>
<p>2.后置通知(@After)：方法运行之后运行</p>
<p>3.正常返回(@AfterReturning)：目标方法正常返回后运行</p>
<p>4.异常返回(@AfterThrowing)：目标方法出现异常后运行</p>
<p>5.环绕通知(@Around)：动态代理，用joinPonit.procceed()来运行目标方法</p>
<p>注意，@Before，@After，@Around无论是否出现异常都会执行</p>
<p>切点表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public int com.demo.test.Aspects.DivTest.div(int,int)</span><br></pre></td></tr></table></figure>

<p>可以用*来代表其中的一部分，代表任意</p>
<p>参数可以用..来代表任意参数</p>
<p>访问权限可以不写，代表任意权限</p>
<p>切点表达式可以直接写在上述注解中（需要在execution中），不过这样显得有些过于麻烦，我们提取公共切点表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(public * com.demo.test.Aspects.DivTest.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointCut</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这样其他方法在引用时，就只需将value字段设置为方法名加上()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;pointCut()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeDiv</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;before div&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AOP的使用步骤：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9865bf7ed075b674b017b4ca4761c438.png" alt="image-20220515005700322"></p>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DivAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public * com.demo.test.Aspects.DivTest.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointCut</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeDiv</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before div&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterDiv</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AfterDiv&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;pointCut()&quot;,returning = &quot;result&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturn</span><span class="params">(JoinPoint joinPoint,Object result)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterReturn&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;pointCut()&quot;,throwing = &quot;ex&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">afterThrowing</span><span class="params">(JoinPoint joinPoint,Exception ex)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Around(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">aroundDiv</span><span class="params">(ProceedingJoinPoint pjp)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;beforeAround&quot;</span>);</span><br><span class="line">        Object o=pjp.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;afterAround&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个通知注解标识的方法的参数中都可以有一个JoinPoint类型的参数，代表切入点的方法信息，并且这个参数必须方法必须防在参数列表的第一个，否则无法解析</p>
<p>JoinPoint类常用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getSignature()	获取方法的信息</span><br><span class="line">getArgs()		获取所有的参数</span><br></pre></td></tr></table></figure>

<p>不同的注解中还有不同的参数，可以为方法装配额外的参数。例如：</p>
<p>@AfterThrowing(value = “pointCut()”,throwing = “ex”)    throwing参数指明了将Exception类的对象装配进名为ex参数中</p>
<p>@AfterReturning(value = “pointCut()”,returning = “result”)    returning 参数表示将返回值装配进名为result的参数中</p>
<p>其余注解的参数也是用这种方法来使用</p>
<p>业务类和切片类都要添加进Spring容器中，用我们之前讲的方法都可以。然后将注解@Aspect标注在切片类上（@Aspect不能标注在方法上）</p>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">beforeAround</span><br><span class="line">before div</span><br><span class="line">DivTest</span><br><span class="line">afterReturn/afterThorwing</span><br><span class="line">AfterDiv</span><br><span class="line">afterAround</span><br></pre></td></tr></table></figure>

<h3 id="EnableAspectJAutoProxy"><a href="#EnableAspectJAutoProxy" class="headerlink" title="@EnableAspectJAutoProxy"></a>@EnableAspectJAutoProxy</h3><h4 id="注解功能"><a href="#注解功能" class="headerlink" title="注解功能"></a>注解功能</h4><p>上一节说到，必须在配置类上加上@EnableAspectJAutoProxy注解才能开启AOP功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(AspectJAutoProxyRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Indicate whether subclass-based (CGLIB) proxies are to be created as opposed</span></span><br><span class="line"><span class="comment">	 * to standard Java interface-based proxies. The default is &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Indicate that the proxy should be exposed by the AOP framework as a &#123;<span class="doctag">@code</span> ThreadLocal&#125;</span></span><br><span class="line"><span class="comment">	 * for retrieval via the &#123;<span class="doctag">@link</span> org.springframework.aop.framework.AopContext&#125; class.</span></span><br><span class="line"><span class="comment">	 * Off by default, i.e. no guarantees that &#123;<span class="doctag">@code</span> AopContext&#125; access will work.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 4.3.1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">exposeProxy</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个注解上有注解@Import(AspectJAutoProxyRegistrar.class)，表示向容器中引入AspectJAutoProxyRegistrar类的组件（对象）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AspectJAutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Register, escalate, and configure the AspectJ auto proxy creator based on the value</span></span><br><span class="line"><span class="comment">	 * of the @&#123;<span class="doctag">@link</span> EnableAspectJAutoProxy#proxyTargetClass()&#125; attribute on the importing</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; class.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(</span></span><br><span class="line"><span class="params">			AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line"></span><br><span class="line">		AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line"></span><br><span class="line">		<span class="type">AnnotationAttributes</span> <span class="variable">enableAspectJAutoProxy</span> <span class="operator">=</span></span><br><span class="line">				AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);</span><br><span class="line">		<span class="keyword">if</span> (enableAspectJAutoProxy != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">&quot;proxyTargetClass&quot;</span>)) &#123;</span><br><span class="line">				AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">&quot;exposeProxy&quot;</span>)) &#123;</span><br><span class="line">				AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AspectJAutoProxyRegistrar类实现了ImportBeanDefinitionRegistrar接口，并用@Import导入，这样可以向容器中注册组件</p>
<p>注册的组件是：AnnotationAwareAspectJAutoProxyCreator</p>
<p>@Enablexxx注解的研究方式：点击去看看它引入了什么组件，组件的功能是什么</p>
<p>AnnotationAwareAspectJAutoProxyCreator实现了这两个接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware</span><br></pre></td></tr></table></figure>

<p>SmartInstantiationAwareBeanPostProcessor：xxxBeanPostProcessor表示是一个后置处理器，可以在初始化前后进行一些操作</p>
<p>BeanFactoryAware：xxxAware是用于获得Spring容器底层组件的接口，BeanFactoryAware用于获得BeanFactory这个组件</p>
<h4 id="AnnotationAwareAspectJAutoProxyCreator组件"><a href="#AnnotationAwareAspectJAutoProxyCreator组件" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator组件"></a>AnnotationAwareAspectJAutoProxyCreator组件</h4><p>AnnotationAwareAspectJAutoProxyCreator是在什么时候生效的：</p>
<p>AnnotationAwareAspectJAutoProxyCreator也是一个BeanPostProccessor，和普通的BeanPostProccessor的创建流程一样</p>
<p>1.创建IOC容器</p>
<p>2.注册配置类，refresh刷新容器</p>
<p>3.刷新容器时会调用方法：registerBeanPostProcessors(beanFactory) 来注册bean的后置处理器来进行拦截</p>
<p>​    1.获取容器中所有注册的BeanPostProcessor的定义（此时还没有创建出来）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>​    <img src="https://img-blog.csdnimg.cn/img_convert/1a85f7c4f61ef84015db8399c2dc5c26.png" alt="image-20220516095556025"></p>
<p>​    2.添加其他的一些BeanProccessor，然后将实现了PriorityOrder接口，Order接口，和没有实现这两个接口的BeanPostProcessor分        开。</p>
<p>​    3.优先注册实现了PriorityOrder接口的BeanPostProcessor</p>
<p>​    4.然后注册实现了Order接口的BeanPostProccessor</p>
<p>​    5.然后注册没有实现优先级接口的BeanPostProccessor</p>
<p>​    6.注册BeanPostProccessor，其实就是根据Bean的定义创建对应的对象，并保存在Spring容器中</p>
<h4 id="创建bean的流程"><a href="#创建bean的流程" class="headerlink" title="创建bean的流程"></a>创建bean的流程</h4><p>对于所有容器中的组件，都是通过以下方法创建的</p>
<p><strong>========================================================================================================</strong></p>
<p>​            创建过程：【doCreateBean】</p>
<p>​            1.创建bean的实例    【Object bean = instanceWrapper.getWrappedInstance()】</p>
<p>​                1.5    这里会有【resolveBeforeInstantiation】，用于提前生成代理对象</p>
<p>​            2.为bean的属性赋值 【populateBean(beanName, mbd, instanceWrapper)】依赖注入</p>
<p>​            3.初始化bean    【exposedObject = initializeBean(beanName, exposedObject, mbd)】</p>
<p>​                    1.处理一部分Aware接口的回调    【invokeAwareMethods(beanName, bean)】</p>
<p>​                    2.应用BeanPostProcessor的前置回调BeanPostProcessorsBeforeInitialization    【wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName)】</p>
<p>​                    3.执行初始化方法    【invokeInitMethods】（用@Bean指定的）</p>
<p>​                    4.应用BeanPostProcessor的BeanPostProcessorsAfterInitialization方法 【wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName)】，在这个方法中也能生成代理对象</p>
<p>​            4.放入Spring容器中</p>
<p><strong>=======================================================================================================</strong></p>
<p>BeanPostProccessor的注册过程和普通bean的注册过程一样都调用的是doCreateBean方法，都会有对应的生命周期中的流程，注册完成后为后面创建其他组件服务</p>
<p>经过上述流程后AnnotationAwareAspectJAutoProxyCreator就创建出来了</p>
<p>AnnotationAwareAspectJAutoProxyCreator实现了InstantiationAwareBeanPostProcessor接口，比普通的BeanPostProcessor多两个方法，而在这个接口中，多了两个方法postProcessBeforeInstantiation，postProcessAfterInstantiation</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InstantiationAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">default</span> Object <span class="title function_">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException 	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">default</span> PropertyValues <span class="title function_">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span></span><br><span class="line">			<span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="完成bean的初始化，创建剩下的单实例bean"><a href="#完成bean的初始化，创建剩下的单实例bean" class="headerlink" title="完成bean的初始化，创建剩下的单实例bean"></a>完成bean的初始化，创建剩下的单实例bean</h4><p>也是调用doCreateBean方法来完成创建，不过在创建之前会先检查缓存中是否有对应的bean，如果有就不再创建（当前，前提是这个bean被设置为单实例的）</p>
<p>【finishBeanFactoryInitialization(beanFactory()】</p>
<p>​    【beanFactory.preInstantiateSingletons()】</p>
<p>遍历容器中所以的bean，获取或者创建对象【getBean】</p>
<p>【getBean()】-&gt; 【doGetBean()】 -&gt;</p>
<p>【getSingleton()】（目的是查找缓存中有没有对应的bean，防止重复创建，所以创建出的bean都会被缓存起来）</p>
<p>-&gt;创建bean（拿到BeanFactory创建bean）</p>
<p>【createBean(beanName, mbd, args)】</p>
<p>给bean一个机会生成代理对象</p>
<p>Object bean = resolveBeforeInstantiation(beanName, mbdToUse)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">回顾创建bean的流程：</span><br><span class="line">createBean</span><br><span class="line">	Object bean = resolveBeforeInstantiation(beanName, mbdToUse)	//提前生成代理对象</span><br><span class="line">	Object beanInstance = doCreateBean(beanName, mbdToUse, args)	//创建bean</span><br><span class="line">		instanceWrapper.getWrappedInstance()						//调用都早方法创建bean实例</span><br><span class="line">		populateBean(beanName, mbd, instanceWrapper)				//属性赋值，依赖注入</span><br><span class="line">		exposedObject = initializeBean(beanName, exposedObject, mbd)//初始化bean</span><br><span class="line">			invokeAwareMethods(beanName, bean)						//Aware接口获取底层组件</span><br><span class="line">			applyBeanPostProcessorsBeforeInitialization				//PostProcessor前置处理</span><br><span class="line">			invokeInitMethods										//@Bean中指定的初始化方法</span><br><span class="line">			applyBeanPostProcessorsAfterInitialization				//PostProcessor后置处理</span><br></pre></td></tr></table></figure>

<p>如果能返回就使用，否则就使用doCreateBean创建对象（和前面的流程一样）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);<span class="comment">//这个是PostProccessor子类新加的</span></span><br><span class="line"><span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">    bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);<span class="comment">//这个是原本的PostProccessor里面的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所谓的代理对象其实是因而后置处理器中，我们可以对对象进行包装后返回，因而也就是代理对象</p>
<p><strong>注意</strong></p>
<p>这里调用的是所有BeanPostProcessor的postProcessBeforeInstantiation方法</p>
<p>postProcessBeforeInstantiation方法是在在resolveBeforeInstantiation调用</p>
<p>postProcessBeforeInitialization方法是在初始化的时候用的</p>
<p>在这里调用所有InstantiationAwareBeanPostProcessor的postProcessBeforeInstantiation</p>
<p>AOP的动态代理的逻辑在这里AnnotationAwareAspectJAutoProxyCreator产生</p>
<p>我们来看看postProcessBeforeInstantiation做了哪些事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;</span><br><span class="line">	<span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(beanClass, beanName);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!StringUtils.hasLength(beanName) || !<span class="built_in">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.advisedBeans.containsKey(cacheKey)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line">			<span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create proxy here if we have a custom TargetSource.</span></span><br><span class="line">	<span class="comment">// Suppresses unnecessary default instantiation of the target bean:</span></span><br><span class="line">	<span class="comment">// The TargetSource will handle target instances in a custom fashion.</span></span><br><span class="line">	<span class="type">TargetSource</span> <span class="variable">targetSource</span> <span class="operator">=</span> getCustomTargetSource(beanClass, beanName);</span><br><span class="line">	<span class="keyword">if</span> (targetSource != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.hasLength(beanName)) &#123;</span><br><span class="line">			<span class="built_in">this</span>.targetSourcedBeans.add(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</span><br><span class="line">		<span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> createProxy(beanClass, beanName, specificInterceptors, targetSource);</span><br><span class="line">		<span class="built_in">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">		<span class="keyword">return</span> proxy;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.首先判断当前bean是否在需要增强的bean（advisedBeans）中【advisedBeans.containsKey(cacheKey)】</p>
<p>2.判断是否是基础的代理类型（Advice之类的）或者切面（@Aspect）【isInfrastructureClass(beanClass)】</p>
<p>3.再判断是否应当跳过【shouldSkip】</p>
<p>​        将所有的增强方法封装成一个增强器，判断是不是对应的类型之类的，这里大多数情况下返回false</p>
<p>这里一般情况下会返回null，然后触发applyBeanPostProcessorsAfterInitialization</p>
<h4 id="applyBeanPostProcessorsAfterInitialization生成代理对象"><a href="#applyBeanPostProcessorsAfterInitialization生成代理对象" class="headerlink" title="applyBeanPostProcessorsAfterInitialization生成代理对象"></a>applyBeanPostProcessorsAfterInitialization生成代理对象</h4><p>AnnotationAwareAspectJAutoProxyCreator会调用applyBeanPostProcessorsAfterInitialization方法生成代理对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span></span><br><span class="line">		<span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> existingBean;</span><br><span class="line">	<span class="keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">current</span> <span class="operator">=</span> processor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">		<span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">		result = current;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>postProcessAfterInitialization中会生成我们需要的AOP代理对象</p>
<p>1.获取我们设置的所有增强器（包装后的增强方法），然后用切入点表达式判断当前bean能不能使用，把能使用的增强器放入到一个集合中，然后判断当前方法需不需要增强，不需要增强（集合大小为0）则直接返回</p>
<p>2.将增强器按照优先级排序</p>
<p>3.将当前bean标志为增强</p>
<p>4.创建代理对象</p>
<p>​        1.将增强器放入增强工厂（【proxyFactory】DefaultAopProxyFactory），用代理工厂创建AOP代理【createAopProxy】</p>
<p>​        有两种AOP代理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ObjenesisCglibAopProxy(config)	CGLIB动态代理</span><br><span class="line">JdkDynamicAopProxy(config)		JDK动态代理</span><br></pre></td></tr></table></figure>

<p>默认使用CGLIB动态代理</p>
<p>​        2.创建代理对象</p>
<p>创建完代理对象后，Spring容器种放置的就是bean的代理对象</p>
<p>至此bean的创建流程就结束了</p>
<p>小记：</p>
<p>总结一些Spring创建对象的大致流程：</p>
<p>Spring容器在启动的时候，扫描指定的包扫描路径下的所有组件，将所有带有@Controller，@Service，@Compoent等将组件注册进Spring容器的注解的类的定义信息保存下来，然后创建对应的BeanFactory并放入到三级缓存中。然后遍历三级缓存，调用beanFactory的getObject方法创建组件。创建组件时，先调用构造器创建对象实例，然后判断当前bean有没有依赖其他组件，如果没有则不需要依赖注入，执行初始化方法后，生成代理对象，放入一级缓存中（Spring容器），如果依赖了其他组件，则提前生成代理对象，放入二级缓存中，然后创建其他其他的bean，等所有bean都按这种方式创建完成了，他们在内存中的位置也就确定了，然后我们再遍历二级缓存，二级缓存中的bean，虽然里面的属性还没有赋值，但是在内存中的位置以及确定了，然后我们就可以根据依赖注入的规则（@Autowired，@Resource）在一级缓存和二级缓存中查找对应的bean，并将其地址赋值到属性字段中，这样就可以完成所有字段依赖注入。完成依赖注入中将其从二级缓存中移除，然后放入到一级缓存中，这样bean就创建完成了。</p>
<p>初始化方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">invokeAwareMethods</span><br><span class="line">postProcessBeforeInitialization:user</span><br><span class="line">PostConstruct</span><br><span class="line">afterPropertiesSet</span><br><span class="line">methodInit</span><br><span class="line">postProcessAfterInitialization:user</span><br></pre></td></tr></table></figure>

<p>Spring如何解决循环依赖问题：</p>
<p>Spring组件之间的依赖关系本质上可以构成一个图，创建对象的过程其实就是图的遍历过程，每个结点就是就是我们要创建的组件，而每一条边就是进行依次依赖注入，我们遍历图的经典算法就是在外层套一个循环，遍历每个点，然后从每个点出来进行深度优先遍历（dfs），然后我们还会使用一个vis数组来记录每个遍历过的点，防止一个点被重复遍历。Spring创建对象的过程其实就是这么做。构造这个依赖关系图的信息保存在BeanDefinition中，创建对象时候会调用三级缓存中的beanFactory来创建对象，如果当前对象不依赖其他组件，也就是在图中是一个孤立的点或者无法到达其他结点，我们就直接创建这个对象然后放入一级缓存中，如果依赖了其他组件，我们先判断这个依赖的组件在一级缓存和二级缓存中有没有，如果有的话，说明出现了循环依赖，就说明依赖的组件之前已经创建过了，把缓存中的对象的引用赋值到对应的属性字段即可，如果没有依赖的对象还没有创建，就递归地创建所依赖的对象，然后也把它的引用赋值过来。按照这个流程完成依赖注入，然后从二级缓存中移除，放入到一级缓存中即可。</p>
<h3 id="AOP执行流程"><a href="#AOP执行流程" class="headerlink" title="AOP执行流程"></a>AOP执行流程</h3><p>获取拦截器链</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br></pre></td></tr></table></figure>

<p>执行拦截器链</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retVal = new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</span><br></pre></td></tr></table></figure>

<p>处理返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retVal = processReturnType(proxy, target, method, retVal);</span><br></pre></td></tr></table></figure>

<p>如果有连接器链，执行连接器链，如果没有，执行原方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">		<span class="meta">@Nullable</span></span><br><span class="line">		<span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">			<span class="type">Object</span> <span class="variable">oldProxy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">			<span class="type">boolean</span> <span class="variable">setProxyContext</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">			<span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">			<span class="type">TargetSource</span> <span class="variable">targetSource</span> <span class="operator">=</span> <span class="built_in">this</span>.advised.getTargetSource();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">					<span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">					oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">					setProxyContext = <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// Get as late as possible to minimize the time we &quot;own&quot; the target, in case it comes from a pool...</span></span><br><span class="line">				target = targetSource.getTarget();</span><br><span class="line">				Class&lt;?&gt; targetClass = (target != <span class="literal">null</span> ? target.getClass() : <span class="literal">null</span>);</span><br><span class="line">				List&lt;Object&gt; chain = <span class="built_in">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">				Object retVal;</span><br><span class="line">				<span class="comment">// Check whether we only have one InvokerInterceptor: that is,</span></span><br><span class="line">				<span class="comment">// no real advice, but just reflective invocation of the target.</span></span><br><span class="line">				<span class="keyword">if</span> (chain.isEmpty() &amp;&amp; CglibMethodInvocation.isMethodProxyCompatible(method)) &#123;</span><br><span class="line">					<span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly.</span></span><br><span class="line">					<span class="comment">// Note that the final invoker must be an InvokerInterceptor, so we know</span></span><br><span class="line">					<span class="comment">// it does nothing but a reflective operation on the target, and no hot</span></span><br><span class="line">					<span class="comment">// swapping or fancy proxying.</span></span><br><span class="line">					Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">					retVal = invokeMethod(target, method, argsToUse, methodProxy);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// We need to create a method invocation...</span></span><br><span class="line">					retVal = <span class="keyword">new</span> <span class="title class_">CglibMethodInvocation</span>(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</span><br><span class="line">				&#125;</span><br><span class="line">				retVal = processReturnType(proxy, target, method, retVal);</span><br><span class="line">				<span class="keyword">return</span> retVal;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (target != <span class="literal">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">					targetSource.releaseTarget(target);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">					<span class="comment">// Restore old proxy.</span></span><br><span class="line">					AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>获取拦截器链，其实就是把我们增强的方法转换为一个统一的类型，然后放入集合List<MethodInterceptor>中</p>
<p>执行逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">	<span class="comment">// We start with an index of -1 and increment early.</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.currentInterceptorIndex == <span class="built_in">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">Object</span> <span class="variable">interceptorOrInterceptionAdvice</span> <span class="operator">=</span></span><br><span class="line">			<span class="built_in">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="built_in">this</span>.currentInterceptorIndex);</span><br><span class="line">       <span class="comment">//省略一些不会发生的步骤……</span></span><br><span class="line">	<span class="comment">// It&#x27;s an interceptor, so we just invoke it: The pointcut will have</span></span><br><span class="line">	<span class="comment">// been evaluated statically before this object was constructed.</span></span><br><span class="line">	<span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的代码可以用下面这张图来表示</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/52e55156c3151266c703521baa50894b.png" alt="image-20220516182358635"></p>
<p>首先我们可以看到这个代码是一个递归的逻辑，递归的终止条件是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We start with an index of -1 and increment early.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.currentInterceptorIndex == <span class="built_in">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当索引到最后一个时，也就是所有的拦截器都已经处理过了，执行我们目标方法，然后返回。</p>
<p>获取下一个拦截器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">interceptorOrInterceptionAdvice</span> <span class="operator">=</span></span><br><span class="line">		<span class="built_in">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="built_in">this</span>.currentInterceptorIndex);</span><br></pre></td></tr></table></figure>

<p>执行它的invoke方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dm.methodMatcher.matches(<span class="built_in">this</span>.method, targetClass, <span class="built_in">this</span>.arguments)) &#123;</span><br><span class="line">	<span class="keyword">return</span> dm.interceptor.invoke(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>invoke方法又会来到这个方法中，获取下一个拦截器并执行，知道所有的拦截器都被执行完，然后执行目标方法，然后回溯执行剩下拦截器的其他逻辑，从而完成所有拦截器的逻辑。</p>
<p>拦截器的顺序在执行之前经过了合理的排序，这样才执行的时候才能按照Around前-&gt;Before-&gt;目标方法-&gt;After-&gt;AfterRurning/AfterThrowing-&gt;Around后的顺序来执行。</p>
<p>各个注解的拦截器：</p>
<p>mi.proceed()每个注解的invoke方法都会执行mi.proceed()方法，然后获取下一个拦截器执行它的invoke方法，每一个invoke方法都好像是后面（序号靠后）的拦截器的代理一样</p>
<p>@Before</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">       <span class="comment">//前置拦截</span></span><br><span class="line">	<span class="built_in">this</span>.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());</span><br><span class="line">       <span class="comment">//接下来就要执行目标方法了(或者其他Before方法)</span></span><br><span class="line">	<span class="keyword">return</span> mi.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@After的拦截器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//这里会执行@Before方法和目标方法</span></span><br><span class="line">		<span class="keyword">return</span> mi.proceed();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//回溯时，无论是否出现异常都会执行执行这个逻辑</span></span><br><span class="line">		invokeAdviceMethod(getJoinPointMatch(), <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@AfterReturning的拦截器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">       <span class="comment">//这里会执行Before方法，目标方法，After方法</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> mi.proceed();</span><br><span class="line">       <span class="comment">//只有在没有异常的时候才会执行这个逻辑</span></span><br><span class="line">	<span class="built_in">this</span>.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());</span><br><span class="line">	<span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@AfterThrowing的拦截器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//这里会执行@Before方法，目标方法，@After方法，@AfterThrowing方法</span></span><br><span class="line">           <span class="comment">//只要这些方法有一个出现异常都会执行下面的@AfterThrowing的方法</span></span><br><span class="line">		<span class="keyword">return</span> mi.proceed();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">if</span> (shouldInvokeOnThrowing(ex)) &#123;</span><br><span class="line">               <span class="comment">//只有在出现异常时才会执行</span></span><br><span class="line">			invokeAdviceMethod(getJoinPointMatch(), <span class="literal">null</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Around执行流程和上述不一样，@Around注解有自己的动态代理机制</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/adb33ab5072d670e87b4db7711f0284f.png" alt="image-20220516190430510"></p>
<p>这里执行proceed()方法后就会执行上述的拦截器链（执行@Before方法，目标方法，@After方法，@AfterThrowing/@AfterReturning方法）</p>
<p>@Around拦截器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">	<span class="keyword">if</span> (!(mi <span class="keyword">instanceof</span> ProxyMethodInvocation)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;MethodInvocation is not a Spring ProxyMethodInvocation: &quot;</span> + mi);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">ProxyMethodInvocation</span> <span class="variable">pmi</span> <span class="operator">=</span> (ProxyMethodInvocation) mi;</span><br><span class="line">	<span class="type">ProceedingJoinPoint</span> <span class="variable">pjp</span> <span class="operator">=</span> lazyGetProceedingJoinPoint(pmi);</span><br><span class="line">	<span class="type">JoinPointMatch</span> <span class="variable">jpm</span> <span class="operator">=</span> getJoinPointMatch(pmi);</span><br><span class="line">       <span class="comment">//执行我们编写的方法</span></span><br><span class="line">	<span class="keyword">return</span> invokeAdviceMethod(pjp, jpm, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Spring异步请求"><a href="#Spring异步请求" class="headerlink" title="Spring异步请求"></a>Spring异步请求</h3><h4 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h4><p>效果展示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Callable&lt;String&gt; <span class="title function_">callableTest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + System.currentTimeMillis());</span><br><span class="line">        Callable&lt;String&gt; callable = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + System.currentTimeMillis());</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + System.currentTimeMillis());</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;callable:hello world&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">return</span> callable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">preHandle</span><br><span class="line">beforeAround</span><br><span class="line">before div</span><br><span class="line">主线程：http-nio-8080-exec-1=&gt;1652709584741</span><br><span class="line">主线程：http-nio-8080-exec-1=&gt;1652709584742</span><br><span class="line">afterReturn</span><br><span class="line">AfterDiv</span><br><span class="line">afterAround</span><br><span class="line">task-1=&gt;1652709584748</span><br></pre></td></tr></table></figure>

<p>2s后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">=========================执行主线程=================================</span><br><span class="line">preHandle</span><br><span class="line">beforeAround</span><br><span class="line">before div</span><br><span class="line">主线程：http-nio-8080-exec-1=&gt;1652709697775</span><br><span class="line">主线程：http-nio-8080-exec-1=&gt;1652709697776</span><br><span class="line">afterReturn</span><br><span class="line">AfterDiv</span><br><span class="line">afterAround</span><br><span class="line">========================执行从线程==============================</span><br><span class="line">task-1=&gt;1652709697785</span><br><span class="line">task-1=&gt;1652709699795</span><br><span class="line">=========================重新发送响应=========================</span><br><span class="line">preHandle</span><br><span class="line">posthandle</span><br><span class="line">afterCompletion</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/img_convert/b9336d67e0efc1224aa90450f017c8c0.png" alt="image-20220516221842262"></p>
<p>我们返回callable对象后，Springboot会另外使用另一个线程池来执行我们的callable，同时主线程结束，DispatchServlet和Filter结束，但是response仍然处于打开的状态，等待我们返回数据。等callable得到结果后，Springboot会重新发一次请求触发DispatchServlet，执行DispatchServlet的声明周期，但是不再执行handler方法，而是直接将得到的callable的返回值作为handler的的执行结果，然后执行后面类型转换或者视图解析的流程。</p>
<h4 id="DefferedResult"><a href="#DefferedResult" class="headerlink" title="DefferedResult"></a>DefferedResult</h4><p>我们可以先把这个对象返回，但是对方查询这个数据时会被阻塞住，我们通过调用setResult方法设置结果。</p>
<p>我们在一个请求中返回一个DefferedResult，但是此时和callable一样，请求不会完成，response仍然是打开是状态，但是线程已经结束，等到其他线程调用了setResult方法后，得到返回值才能完成本次请求，可以用于消息队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> LinkedBlockingDeque&lt;DeferredResult&lt;Object&gt;&gt; mq = <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DeferredResult&lt;Object&gt; <span class="title function_">callableTest</span><span class="params">()</span> &#123;</span><br><span class="line">        DeferredResult&lt;Object&gt; objectDeferredResult = <span class="keyword">new</span> <span class="title class_">DeferredResult</span>&lt;&gt;();</span><br><span class="line">        mq.add(objectDeferredResult);</span><br><span class="line">        <span class="keyword">return</span> objectDeferredResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;save&quot;)</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveObject</span><span class="params">()</span> &#123;</span><br><span class="line">        DeferredResult&lt;Object&gt; obj = mq.take();</span><br><span class="line">        obj.setResult(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回DeferredResult后，会等待其他线程调用setResult方法完成请求，否则response会一直处于打开的状态，调用setResult方法后，会重新发一次请求完成流程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://thgg.github.io/2022/11/30/Springboot%E6%B3%A8%E8%A7%A3/" data-id="clb3n4wz00004d8wwgf0u4llj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2022/11/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">设计模式</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/11/30/Springboot%E6%B3%A8%E8%A7%A3/">Springboot注解</a>
          </li>
        
          <li>
            <a href="/2022/11/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
          </li>
        
          <li>
            <a href="/2022/11/30/Dubbo/">Dubbo</a>
          </li>
        
          <li>
            <a href="/2022/11/30/Springboot-%E4%B8%8B%E7%AF%87/">Springboot(下篇)</a>
          </li>
        
          <li>
            <a href="/2022/11/30/Springboot-%E4%B8%8A%E7%AF%87/">Springboot(上篇)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 LTH<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>