<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Dubbo | 天航的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Dubbo学习https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_41157588&#x2F;article&#x2F;details&#x2F;106737191 概述分布式系统分布式系统：建立在网络之上的软件系统 分布式系统是若干独立计算机（服务器）的集合，这些计算机对于用户来说就像单个系统 Dubbo就是用于治理这些分布式系统的系统 系统的发展 单一应用架构（1~10）[外链图片转存失败,源站可能有防盗链机制,建议将图片保">
<meta property="og:type" content="article">
<meta property="og:title" content="Dubbo">
<meta property="og:url" content="http://thgg.github.io/2022/11/30/Dubbo/index.html">
<meta property="og:site_name" content="天航的博客">
<meta property="og:description" content="Dubbo学习https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_41157588&#x2F;article&#x2F;details&#x2F;106737191 概述分布式系统分布式系统：建立在网络之上的软件系统 分布式系统是若干独立计算机（服务器）的集合，这些计算机对于用户来说就像单个系统 Dubbo就是用于治理这些分布式系统的系统 系统的发展 单一应用架构（1~10）[外链图片转存失败,源站可能有防盗链机制,建议将图片保">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/7742ff161f087c849eb5023dd0168333.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/e6021eccf8f18d874f5ca87748326208.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/875c4c307e62fdbb9be2c8aeb9e75eb0.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/9303ea4e14355fa4bab4367a8442ed3b.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/58ef0a02348a638808d633247f68ef36.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/8fd4f7a7f3e883cc1e9a66e0c4ba9e13.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/b50cfb5974e30d0e9956bb06837c80ba.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/04e3606cd58b1f4f35531617f697e0d6.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/96ce22a7077e3b9b9dc1d2dc06004f0e.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200612152443622.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/fd04b53d22852ee0083b5349b5b94156.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/ab96410ed357df554514611a90b06352.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/e1db821cf9e25b0abd009bcf5db669ca.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/8e1bfff67d8e682a9f8c1cde13d8f3db.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/f07f308730ad586f1a64184da62b2c34.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/a57d57a0e13cb73efa588c4272ee8af1.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/ebed4e6829af25a0348af63d3c4cd0b8.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/9b45062986f034a01041590543642c46.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/ec8797a43571bf74526d4f4d332f4c27.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/41bb9ab61c95cc66232dd6d77e2465d4.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/b2db045aea8214e097eed8fa52a0b7c7.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/43c9a0b31535f7049ddc351bfff48df9.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/f035bec86009c33287dcc6592d01f395.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/45aa41e6829fe06cbc413fc5d1294c7c.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/3a63b2fd3d3b3dd6445db5de464df198.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/90dff32874e123b86a0b9670cf67af11.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200613171217369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTU3NTg4,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/8565f8f4bc57a0f8d3f8058d9cee52a4.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/e44883fcec0ad3bb40992bf3010e49d2.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/2b5d7d1815afa07b018f5ecf0fd9f03a.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200613171806762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTU3NTg4,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2022-11-30T11:18:10.000Z">
<meta property="article:modified_time" content="2022-11-30T11:18:21.566Z">
<meta property="article:author" content="LTH">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/img_convert/7742ff161f087c849eb5023dd0168333.png">
  
    <link rel="alternate" href="/atom.xml" title="天航的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">天航的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://thgg.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Dubbo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/30/Dubbo/" class="article-date">
  <time datetime="2022-11-30T11:18:10.000Z" itemprop="datePublished">2022-11-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Dubbo
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Dubbo学习"><a href="#Dubbo学习" class="headerlink" title="Dubbo学习"></a>Dubbo学习</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41157588/article/details/106737191">https://blog.csdn.net/qq_41157588/article/details/106737191</a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h3><p>分布式系统：建立在网络之上的软件系统</p>
<p>分布式系统是若干独立计算机（服务器）的集合，这些计算机对于用户来说就像单个系统</p>
<p>Dubbo就是用于治理这些分布式系统的系统</p>
<h3 id="系统的发展"><a href="#系统的发展" class="headerlink" title="系统的发展"></a>系统的发展</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/7742ff161f087c849eb5023dd0168333.png" alt="image-20220603120448326"></p>
<h4 id="单一应用架构（1-10）"><a href="#单一应用架构（1-10）" class="headerlink" title="单一应用架构（1~10）"></a>单一应用架构（1~10）</h4><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-yMwAjait-1657813726361)(<a target="_blank" rel="noopener" href="https://s2.loli.net/2022/06/03/CwsRTEJD28MtKHm.png)]">https://s2.loli.net/2022/06/03/CwsRTEJD28MtKHm.png)]</a></p>
<p>一开始流量很小，整个应用可以设计为一个单节点应用，部署到一个服务器上，开发部署都很简单，如果流量变大了，可以增加服务器的个数来应对增大的并发量</p>
<p>缺点：</p>
<ol>
<li>难以扩展</li>
<li>系统开发困难，多个人开发一个应用容易把应用改乱</li>
<li>每次修改完都需要重新打包部署到所有服务器上，后面应用的jar包越来越大，单台服务器运行这个jar包都会比较吃力，靠增加结点也难有性能上的提升</li>
</ol>
<h3 id="垂直应用架构（10-1000）"><a href="#垂直应用架构（10-1000）" class="headerlink" title="垂直应用架构（10~1000）"></a>垂直应用架构（10~1000）</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/e6021eccf8f18d874f5ca87748326208.png" alt="image-20220603120341997"></p>
<p>把功能分解若干小服务，部署到不同的服务器上，每一个小服务都包含有界面，服务，数据访问，彼此之间相互独立</p>
<p>优点：</p>
<ol>
<li>协同开发变得容易，同事之间可以开发不同的小服务，互不干扰</li>
<li>扩展容易，可以精确扩展我们想要的服务（为某个小服务添加服务器）</li>
</ol>
<p>缺点：</p>
<ol>
<li>界面和业务逻辑需要分开（界面美化会比较频繁）</li>
<li>应用和应用之间不可能完全独立，应用之间往往会有交互</li>
</ol>
<h3 id="分布式服务架构"><a href="#分布式服务架构" class="headerlink" title="分布式服务架构"></a>分布式服务架构</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/875c4c307e62fdbb9be2c8aeb9e75eb0.png" alt="image-20220603120532659"></p>
<p>将核心业务逻辑和界面分离出来（前后端分离），这样修改界面的时候，不需要重新部署业务逻辑相关的代码</p>
<p>调用服务的方式是RPC（远程过程调用）</p>
<p>分布式服务框架也还没有达到最完美的程度，当我们的服务越来越多，需要的服务器也就越来越多，服务器资源的浪费就十分严重，如果我们能动态监控各个服务的运行情况，根据服务的访问量来动态调度服务器资源，不就能解决资源问题，让服务器资源能得到充分利用了吗，正所谓好要用到刀刃上，问解决这个问题就有了流动计算架构</p>
<h3 id="流动计算架构"><a href="#流动计算架构" class="headerlink" title="流动计算架构"></a>流动计算架构</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/9303ea4e14355fa4bab4367a8442ed3b.png" alt="image-20220603121613225"></p>
<p>流动计算架构可以在上述基础上设置调度和治理中心，基于访问容量试试管理集群容量，提高集群利用率</p>
<h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>远程过程调用，进程通信的一种方式</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/58ef0a02348a638808d633247f68ef36.png" alt="image-20220603122105603"></p>
<p>其实就是应用程序调用应用层协议（比如Http）和运输层协议（比如TCP）和其他使用相同协议的应用程序进行交互的过程</p>
<p>举个例子，我们进行RPC的时候，大概需要经过这些流程</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-DnYK5ohC-1657813726364)(<a target="_blank" rel="noopener" href="https://s2.loli.net/2022/06/03/Ku7cFkAEjeXBpxg.png)]">https://s2.loli.net/2022/06/03/Ku7cFkAEjeXBpxg.png)]</a></p>
<p>客户端发起调用命令，将参数进行序列化，传递给服务器，服务器将参数反序列化后，调用服务，将返回值序列化后返回给客户端</p>
<p>影响一个RPC框架性能的因素主要是连接建立的速度和序列化和反序列化的速度（XML&lt;JOSN&lt;二进制流）</p>
<h2 id="Dubbob基础"><a href="#Dubbob基础" class="headerlink" title="Dubbob基础"></a>Dubbob基础</h2><p>Dubbo是Java的高性能RPC框架</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/8fd4f7a7f3e883cc1e9a66e0c4ba9e13.png" alt="image-20220603132516618"></p>
<ul>
<li>面向接口代理，调用起来更加方便</li>
<li>负载均衡，一个服务在部署到多个服务器上时，让每个服务器的访问量更可能地均衡</li>
<li>服务注册和发现，监控服务的状态（运行还是宕机），统计服务部署到了哪些服务器上，完成这个工作的组件叫做注册中心</li>
<li>给第三方提供扩展的接口</li>
<li>运行流量调度，让不同的服务器承载不同 的流量。同时我们可以让开发后的新服务部署到一部分服务器上，另一些服务器依然使用老服务（新服务可能不稳定，可以测试新服务的表现），经过一段时间的测试，没有问题后再将新服务部署到所有的服务器上（灰度发布）</li>
<li>通过一个可视化的web界面来监控集群的运行状态</li>
</ul>
<h3 id="Dobbo应用的架构"><a href="#Dobbo应用的架构" class="headerlink" title="Dobbo应用的架构"></a>Dobbo应用的架构</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/b50cfb5974e30d0e9956bb06837c80ba.png" alt="image-20220603133928661"></p>
<p>服务提供者运行在Dubbo容器上提供服务，并将服务注册到注册中心里面，服务消费者从注册中心里拉取服务列表，并调用里面的服务，服务消费者和服务提供者定期给monitor发送自己的信息，告诉自己的存活状态</p>
<h3 id="注册中心Zookeeper"><a href="#注册中心Zookeeper" class="headerlink" title="注册中心Zookeeper"></a>注册中心Zookeeper</h3><p>Dubbo软件架构需要注册中心，官网推荐使用zookeeper</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/04e3606cd58b1f4f35531617f697e0d6.png" alt="image-20220603145517827"></p>
<p>zookeeper是树形的目录结构</p>
<p>windows下直接启动或报错，报错原因是没有找到配置文件，所以我们需要重命名他的配置文件</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/96ce22a7077e3b9b9dc1d2dc06004f0e.png" alt="image-20220603150129725"></p>
<p>然后通过bin目录下的zkServer.cmd启动服务，服务端口是2181，zkCli.cmd打开客户端</p>
<h3 id="监控中心Monitor"><a href="#监控中心Monitor" class="headerlink" title="监控中心Monitor"></a>监控中心Monitor</h3><p>监控中心可以为我们提供可视化的监控界面，这里是从github上下载的incubator-dubbo-ops-master用于监控dubbo，本质上是一个springboot项目，把它打成jar包dubbo-admin-0.0.1-SNAPSHOT.jar，然后运行这个jar包就能运行管理控制台，端口号是7001,账号密码都是root</p>
<h3 id="入门项目"><a href="#入门项目" class="headerlink" title="入门项目"></a>入门项目</h3><p>服务消费者调用订单服务，服务提供者提供订单服务</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-W8IZ0XGo-1657813726367)(<a target="_blank" rel="noopener" href="https://s2.loli.net/2022/06/03/K21GB3HEoXpzr6I.png)]">https://s2.loli.net/2022/06/03/K21GB3HEoXpzr6I.png)]</a></p>
<p>在分布式架构中，所以的模块会有一些公共的依赖文件，比如实体bean等，如果采用直接复制的方式，如果bean需要增加一些字段，所有的项目都需要更改，所以我们可以把这些公共的部分抽离出来，单独放在一个项目中供其他项目使用即可，这样既可以减少代码量，修改起来也会很方便</p>
<p>实体bean：</p>
<p>前面提到过，在传递参数的时候需要将对象进行序列化，所以对象必须实现Serializable接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserAddress</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String userAddress; <span class="comment">//用户地址</span></span><br><span class="line">    <span class="keyword">private</span> String userId; <span class="comment">//用户id</span></span><br><span class="line">    <span class="keyword">private</span> String consignee; <span class="comment">//收货人</span></span><br><span class="line">    <span class="keyword">private</span> String phoneNum; <span class="comment">//电话号码</span></span><br><span class="line">    <span class="keyword">private</span> String isDefault; <span class="comment">//是否为默认地址    Y-是     N-否</span></span><br><span class="line">    <span class="comment">//get     set </span></span><br><span class="line">    <span class="comment">//有参构造  无参构造</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>服务提供者：</p>
<p>服务接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用户服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 按照用户id返回所有的收货地址</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title function_">getUserAddressList</span><span class="params">(String userId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title function_">getUserAddressList</span><span class="params">(String userId)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">UserAddress</span> <span class="variable">address1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserAddress</span>(<span class="number">1</span>, <span class="string">&quot;河南省郑州巩义市宋陵大厦2F&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;安然&quot;</span>, <span class="string">&quot;150360313x&quot;</span>, <span class="string">&quot;Y&quot;</span>);</span><br><span class="line">		<span class="type">UserAddress</span> <span class="variable">address2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserAddress</span>(<span class="number">2</span>, <span class="string">&quot;北京市昌平区沙河镇沙阳路&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;情话&quot;</span>, <span class="string">&quot;1766666395x&quot;</span>, <span class="string">&quot;N&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> Arrays.asList(address1,address2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务消费者：</p>
<p>调用服务的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化订单</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initOrder</span><span class="params">(String userID)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接口实现：</p>
<p>这里的UserService的实现并不在这个项目中，只是一个接口，所以需要我们使用RPC框架</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> UserService userService;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initOrder</span><span class="params">(String userID)</span> &#123;</span><br><span class="line">        <span class="comment">//查询用户的收货地址</span></span><br><span class="line">        List&lt;UserAddress&gt; userAddressList = userService.getUserAddressList(userID);</span><br><span class="line">        System.out.println(userAddressList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以看到这里的接口（UserService）和实体Bean（User）是所有项目通用的，我们把他们抽离出来放到一个新的项目里面，供其他项目引入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;com.atguigu.gmall&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;gmall-interface&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;<span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;groupId&gt;com.atguigu.gmall&lt;/groupId&gt;</code> 这个是项目名</p>
<p><code>&lt;artifactId&gt;gmall-interface&lt;/artifactId&gt;</code>  这个是工程目录</p>
<h4 id="服务提供者dubbo框架配置"><a href="#服务提供者dubbo框架配置" class="headerlink" title="服务提供者dubbo框架配置"></a>服务提供者dubbo框架配置</h4><p>引入dubbo和zookeeper</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--dubbo--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--注册中心是 zookeeper，引入zookeeper客户端--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编写xml配置类，将当前服务注册进dubbo框架中</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">		http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">		http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1、指定当前服务/应用的名字(同样的服务名字相同，不要和别的服务同名)--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;user-service-provider&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:application</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--2、指定注册中心的位置--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot;&gt;&lt;/dubbo:registry&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">&quot;zookeeper&quot;</span> <span class="attr">address</span>=<span class="string">&quot;127.0.0.1:2181&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:registry</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--3、指定通信规则（通信协议? 服务端口）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20880&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:protocol</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--4、暴露服务 让别人调用 ref指向服务的真正实现对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.lemon.gmail.service.UserService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--服务的实现--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userServiceImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lemon.gmail.service.impl.UserServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动spring容器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ClassPathXmlApplicationContext applicationContext= <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;provider.xml&quot;</span>);</span><br><span class="line">        applicationContext.start();</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>System.in.read();是为了阻塞住当前程序，防止程序退出，达到任意键退出的效果</p>
<h4 id="服务消费者dubbo框架配置"><a href="#服务消费者dubbo框架配置" class="headerlink" title="服务消费者dubbo框架配置"></a>服务消费者dubbo框架配置</h4><p>还是引入这两个中间件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--dubbo--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--注册中心是 zookeeper，引入zookeeper客户端--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编写xml配置文件，从注册中心拉取服务并将远程的组件放入当前项目的spring容器中</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://dubbo.apache.org/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">		http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">		http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--包扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.lemon.gmail.service.impl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--指定当前服务/应用的名字(同样的服务名字相同，不要和别的服务同名)--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;order-service-consumer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:application</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定注册中心的位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://127.0.0.1:2181&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:registry</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--调用远程暴露的服务，生成远程服务代理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;com.lemon.gmail.service.UserService&quot;</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用的时候就可以直接用@Autowire注入，就好像这个组件就在本地的spring容器中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> UserService userService;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initOrder</span><span class="params">(String userID)</span> &#123;</span><br><span class="line">        <span class="comment">//查询用户的收货地址</span></span><br><span class="line">        List&lt;UserAddress&gt; userAddressList = userService.getUserAddressList(userID);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//为了直观的看到得到的数据，以下内容也可不写</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前接收到的userId=&gt; &quot;</span>+userID);</span><br><span class="line">        System.out.println(<span class="string">&quot;**********&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;查询到的所有地址为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (UserAddress userAddress : userAddressList) &#123;</span><br><span class="line">            <span class="comment">//打印远程服务地址的信息</span></span><br><span class="line">            System.out.println(userAddress.getUserAddress());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="简易监控中心"><a href="#简易监控中心" class="headerlink" title="简易监控中心"></a>简易监控中心</h3><p>将 dubbo-monitor-simple-2.0.0-assembly.tar.gz 压缩包解压至当前文件夹，解压后config文件查看properties的配置是否是本地的zookeeper，如果不是本地的zookeeper则需要修改ip和端口<br>打开解压后的 assembly.bin 文件，start.bat 启动dubbo-monitor-simple监控中心<br>在浏览器 localhost:8080 ，可以看到一个监控中心。<br>在服务提供者和消费者的xml中配置以下内容，再次启动服务提供和消费者启动类。</p>
<pre><code>&lt;!--dubbo-monitor-simple监控中心发现的配置--&gt;
&lt;dubbo:monitor protocol=&quot;registry&quot;&gt;&lt;/dubbo:monitor&gt;
&lt;!--&lt;dubbo:monitor address=&quot;127.0.0.1:7070&quot;&gt;&lt;/dubbo:monitor&gt;--&gt;
</code></pre>
<h3 id="Springboot整合Dubbo"><a href="#Springboot整合Dubbo" class="headerlink" title="Springboot整合Dubbo"></a>Springboot整合Dubbo</h3><p><img src="https://img-blog.csdnimg.cn/20200612152443622.png" alt="在这里插入图片描述"></p>
<p>导入pom依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">	<span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lemon.gmail<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gmail-interface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这个starter帮我们引入了springboot,duboo,zookeeper相关的依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><relativePath />用于获取父工程的版本信息<dependencyManagement></p>
<h4 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h4><p>这个用来提供服务的实现类，一个一个在配置文件中配置端口显然过于麻烦，我们可以使用Dubbo家的@Service注解，而Spring的@Service可以使用@Component注解代替</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span><span class="comment">//dubbo的服务暴露</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title function_">getUserAddressList</span><span class="params">(String userId)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">UserAddress</span> <span class="variable">address1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserAddress</span>(<span class="number">1</span>, <span class="string">&quot;河南省郑州巩义市宋陵大厦2F&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;安然&quot;</span>, <span class="string">&quot;150360313x&quot;</span>, <span class="string">&quot;Y&quot;</span>);</span><br><span class="line">		<span class="type">UserAddress</span> <span class="variable">address2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserAddress</span>(<span class="number">2</span>, <span class="string">&quot;北京市昌平区沙河镇沙阳路&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;情话&quot;</span>, <span class="string">&quot;1766666395x&quot;</span>, <span class="string">&quot;N&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> Arrays.asList(address1,address2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>properties配置文件：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#端口需要和8080错开</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8082</span></span><br><span class="line"><span class="comment">#服务名称</span></span><br><span class="line"><span class="attr">dubbo.application.name</span>=<span class="string">boot-user-service-provider</span></span><br><span class="line"><span class="comment">#注册中心的地址</span></span><br><span class="line"><span class="attr">dubbo.registry.address</span>=<span class="string">127.0.0.1:2181</span></span><br><span class="line"><span class="comment">#注册中心的类型</span></span><br><span class="line"><span class="attr">dubbo.registry.protocol</span>=<span class="string">zookeeper</span></span><br><span class="line"><span class="comment">#协议名称</span></span><br><span class="line"><span class="attr">dubbo.protocol.name</span>=<span class="string">dubbo</span></span><br><span class="line"><span class="comment">#对外暴露的端口号</span></span><br><span class="line"><span class="attr">dubbo.protocol.port</span>=<span class="string">20880</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#连接监控中心</span></span><br><span class="line"><span class="attr">dubbo.monitor.protocol</span>=<span class="string">registry</span></span><br></pre></td></tr></table></figure>

<p>启动springboot</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDubbo</span> <span class="comment">//开启基于注解的dubbo功能</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BootProviderApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(BootProviderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h4><p>服务消费者所需的pom依赖和服务提供者相同</p>
<p>调用服务的方式也类似</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span><span class="comment">//引用远程提供者服务</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title function_">initOrder</span><span class="params">(String userID)</span> &#123;</span><br><span class="line">        <span class="comment">//查询用户的收货地址</span></span><br><span class="line">        List&lt;UserAddress&gt; userAddressList = userService.getUserAddressList(userID);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;当前接收到的userId=&gt; &quot;</span>+userID);</span><br><span class="line">        System.out.println(<span class="string">&quot;**********&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;查询到的所有地址为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (UserAddress userAddress : userAddressList) &#123;</span><br><span class="line">            <span class="comment">//打印远程服务地址的信息</span></span><br><span class="line">            System.out.println(userAddress.getUserAddress());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userAddressList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只是这里不再使用@Autowired注解，而是使用Dubbo家的@Reference</p>
<p>用于测试的controller</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/initOrder&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title function_">initOrder</span><span class="params">(<span class="meta">@RequestParam(&quot;uid&quot;)</span>String userId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> orderService.initOrder(userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件：</p>
<p>检测中心的端口号是8080，所以这里的端口需要和区分</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8081</span></span><br><span class="line"><span class="attr">dubbo.application.name</span>=<span class="string">boot-order-service-consumer</span></span><br><span class="line"><span class="attr">dubbo.registry.address</span>=<span class="string">zookeeper://127.0.0.1:2181</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#连接监控中心 注册中心协议</span></span><br><span class="line"><span class="attr">dubbo.monitor.protocol</span>=<span class="string">registry</span></span><br></pre></td></tr></table></figure>

<p>dubbo.registry.address=zookeeper://127.0.0.1:2181直接使用这个写法就不要设置protocol</p>
<p>编写启动类</p>
<p>也要加上@EnableDubbo注解，表示支持使用dubbo的注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDubbo</span> <span class="comment">//开启基于注解的dubbo功能</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BootConsumerApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        SpringApplication.run(BootConsumerApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务消费者应当在服务提供者启动之后再启动，否则会启动报错（下面可以配置这个参数）</p>
<p>我们可以看到服务消费者在Controller中像是调用本地的service一样调用UserService（感觉甚至比Feign还要好用）</p>
<p>Feign是根据服务名称来进行RPC</p>
<p>Dubbo直接根据Service的Bean的类型来进行RPC</p>
<h3 id="常用参数配置"><a href="#常用参数配置" class="headerlink" title="常用参数配置"></a>常用参数配置</h3><p><a target="_blank" rel="noopener" href="https://dubbo.apache.org/zh/docs/v2.7/user/configuration/annotation/">注解配置 | Apache Dubbo</a></p>
<p>配置参数编写规则：</p>
<table>
<thead>
<tr>
<th>Config Type</th>
<th>单数配置</th>
<th>复数配置</th>
</tr>
</thead>
<tbody><tr>
<td>application</td>
<td>dubbo.application.xxx=xxx</td>
<td>dubbo.applications.{id}.xxx=xxx dubbo.applications.{name}.xxx=xxx</td>
</tr>
<tr>
<td>protocol</td>
<td>dubbo.protocol.xxx=xxx</td>
<td>dubbo.protocols.{id}.xxx=xxx dubbo.protocols.{name}.xxx=xxx</td>
</tr>
<tr>
<td>module</td>
<td>dubbo.module.xxx=xxx</td>
<td>dubbo.modules.{id}.xxx=xxx dubbo.modules.{name}.xxx=xxx</td>
</tr>
<tr>
<td>registry</td>
<td>dubbo.registry.xxx=xxx</td>
<td>dubbo.registries.{id}.xxx=xxx</td>
</tr>
<tr>
<td>monitor</td>
<td>dubbo.monitor.xxx=xxx</td>
<td>dubbo.monitors.{id}.xxx=xxx</td>
</tr>
<tr>
<td>config-center</td>
<td>dubbo.config-center.xxx=xxx</td>
<td>dubbo.config-centers.{id}.xxx=xxx</td>
</tr>
<tr>
<td>metadata-report</td>
<td>dubbo.metadata-report.xxx=xxx</td>
<td>dubbo.metadata-reports.{id}.xxx=xxx</td>
</tr>
<tr>
<td>ssl</td>
<td>dubbo.ssl.xxx=xxx</td>
<td>dubbo.ssls.{id}.xxx=xxx</td>
</tr>
<tr>
<td>metrics</td>
<td>dubbo.metrics.xxx=xxx</td>
<td>dubbo.metricses.{id}.xxx=xxx</td>
</tr>
<tr>
<td>provider</td>
<td>dubbo.provider.xxx=xxx</td>
<td>dubbo.providers.{id}.xxx=xxx</td>
</tr>
<tr>
<td>consumer</td>
<td>dubbo.consumer.xxx=xxx</td>
<td>dubbo.consumers.{id}.xxx=xxx</td>
</tr>
<tr>
<td>service</td>
<td>dubbo.service.{interfaceName}.xxx=xxx</td>
<td>无</td>
</tr>
<tr>
<td>reference</td>
<td>dubbo.reference.{interfaceName}.xxx=xxx</td>
<td>无</td>
</tr>
<tr>
<td>method</td>
<td>dubbo.service.{interfaceName}.{methodName}.xxx=xxx dubbo.reference.{interfaceName}.{methodName}.xxx=xxx</td>
<td>无</td>
</tr>
<tr>
<td>argument</td>
<td>dubbo.service.{interfaceName}.{methodName}.{arg-index}.xxx=xxx</td>
<td>无</td>
</tr>
</tbody></table>
<p>常用配置项</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>对应URL参数</th>
<th>类型</th>
<th>缺省值</th>
<th>描述</th>
<th>兼容性</th>
</tr>
</thead>
<tbody><tr>
<td>timeout</td>
<td>default.timeout</td>
<td>int</td>
<td>1000</td>
<td>远程服务调用超时时间(毫秒)</td>
<td>1.0.16以上版本</td>
</tr>
<tr>
<td>retries</td>
<td>default.retries</td>
<td>int</td>
<td>2</td>
<td>远程服务调用重试次数，不包括第一次调用，不需要重试请设为0,仅在cluster为failback/failover时有效</td>
<td>1.0.16以上版本</td>
</tr>
<tr>
<td>loadbalance</td>
<td>default.loadbalance</td>
<td>string</td>
<td>random</td>
<td>负载均衡策略，可选值：random,roundrobin,leastactive，分别表示：随机，轮询，最少活跃调用</td>
<td>1.0.16以上版本</td>
</tr>
<tr>
<td>async</td>
<td>default.async</td>
<td>boolean</td>
<td>false</td>
<td>是否缺省异步执行，不可靠异步，只是忽略返回值，不阻塞执行线程</td>
<td>2.0.0以上版本</td>
</tr>
<tr>
<td>connections</td>
<td>default.connections</td>
<td>int</td>
<td>100</td>
<td>每个服务对每个提供者的最大连接数，rmi、http、hessian等短连接协议支持此配置，dubbo协议长连接不支持此配置</td>
<td>1.0.16以上版本</td>
</tr>
<tr>
<td>generic</td>
<td>generic</td>
<td>boolean</td>
<td>false</td>
<td>是否缺省泛化接口，如果为泛化接口，将返回GenericService</td>
<td>2.0.0以上版本</td>
</tr>
<tr>
<td>check</td>
<td>check</td>
<td>boolean</td>
<td>true</td>
<td>启动时检查提供者是否存在，true报错，false忽略</td>
<td>1.0.16以上版本</td>
</tr>
<tr>
<td>proxy</td>
<td>proxy</td>
<td>string</td>
<td>javassist</td>
<td>生成动态代理方式，可选：jdk/javassist</td>
<td>2.0.5以上版本</td>
</tr>
<tr>
<td>owner</td>
<td>owner</td>
<td>string</td>
<td></td>
<td>调用服务负责人，用于服务治理，请填写负责人公司邮箱前缀</td>
<td>2.0.5以上版本</td>
</tr>
<tr>
<td>actives</td>
<td>default.actives</td>
<td>int</td>
<td>0</td>
<td>每服务消费者每服务每方法最大并发调用数</td>
<td>2.0.5以上版本</td>
</tr>
<tr>
<td>cluster</td>
<td>default.cluster</td>
<td>string</td>
<td>failover</td>
<td>集群方式，可选：failover/failfast/failsafe/failback/forking</td>
<td>2.0.5以上版本</td>
</tr>
<tr>
<td>filter</td>
<td>reference.filter</td>
<td>string</td>
<td></td>
<td>服务消费方远程调用过程拦截器名称，多个名称用逗号分隔</td>
<td>2.0.5以上版本</td>
</tr>
<tr>
<td>listener</td>
<td>invoker.listener</td>
<td>string</td>
<td></td>
<td>服务消费方引用服务监听器名称，多个名称用逗号分隔</td>
<td>2.0.5以上版本</td>
</tr>
<tr>
<td>registry</td>
<td></td>
<td>string</td>
<td>缺省向所有registry注册</td>
<td>向指定注册中心注册，在多个注册中心时使用，值为<a href="dubbo:registry">dubbo:registry</a>的id属性，多个注册中心ID用逗号分隔，如果不想将该服务注册到任何registry，可将值设为N/A</td>
<td>2.0.5以上版本</td>
</tr>
<tr>
<td>layer</td>
<td>layer</td>
<td>string</td>
<td></td>
<td>服务调用者所在的分层。如：biz、dao、intl:web、china:acton。</td>
<td>2.0.7以上版本</td>
</tr>
<tr>
<td>init</td>
<td>init</td>
<td>boolean</td>
<td>false</td>
<td>是否在afterPropertiesSet()时饥饿初始化引用，否则等到有人注入或引用该实例时再初始化。</td>
<td>2.0.10以上版本</td>
</tr>
<tr>
<td>cache</td>
<td>cache</td>
<td>string/boolean</td>
<td></td>
<td>以调用参数为key，缓存返回结果，可选：lru, threadlocal, jcache等</td>
<td>Dubbo2.1.0及其以上版本支持</td>
</tr>
<tr>
<td>validation</td>
<td>validation</td>
<td>boolean</td>
<td></td>
<td>是否启用JSR303标准注解验证，如果启用，将对方法参数上的注解进行校验</td>
<td>Dubbo2.1.0及其以上版本支持</td>
</tr>
</tbody></table>
<p>配置文件的优先级</p>
<p>虚拟机参数-D &gt; application.properties &gt; dubbo.properties</p>
<h4 id="启动时检查（check）"><a href="#启动时检查（check）" class="headerlink" title="启动时检查（check）"></a>启动时检查（check）</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/fd04b53d22852ee0083b5349b5b94156.png" alt="image-20220603222025753"></p>
<p>dubbo.consumer对所有的接口进行统一配置</p>
<p>dubbo.consumer.check=false</p>
<p>在启动的时候会检查依赖的bean有没有注册要注册中心里面，如果没有则检查失败，启动报错。</p>
<p>如果出现了循环依赖需要将这个设置为false。这样在用到这个bean的时候才会检查是否存在</p>
<p>这种方式是配置所有的接口，我们也可以精确配置某一个接口，或者配置注册中心是否要检查</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ab96410ed357df554514611a90b06352.png" alt="image-20220603222954099"></p>
<h4 id="超时设置（timeout）"><a href="#超时设置（timeout）" class="headerlink" title="超时设置（timeout）"></a>超时设置（timeout）</h4><p>RPC的默认超时时间是1s，防止大量线程阻塞，导致资源耗尽</p>
<p>xml配置</p>
<p>全局配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:consumer check=&quot;false&quot;&gt;&lt;/dubbo:consumer&gt;</span><br></pre></td></tr></table></figure>

<p>精确配置：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e1db821cf9e25b0abd009bcf5db669ca.png" alt="image-20220603223908515"></p>
<p>精确优先，精确度相同时，消费者配置大于提供者配置</p>
<p>配置文件配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dubbo.consumer.timeout=5000</span><br></pre></td></tr></table></figure>

<h4 id="重试次数（retries）"><a href="#重试次数（retries）" class="headerlink" title="重试次数（retries）"></a>重试次数（retries）</h4><p>在服务调用失败的时候，重试的次数（第一次不算），配置方法和超时一样</p>
<p>幂等操作可以设置重试次数，非幂等操作不能设置重试次数</p>
<p>不重试设置为0即可</p>
<p>在上述的dubbo:consumer或者dubbo:reference设置参数即可</p>
<h4 id="多版本"><a href="#多版本" class="headerlink" title="多版本"></a>多版本</h4><p>放入注册中心的组件发送变化时，组件的版本也就发送了变化</p>
<p>可以用version设置bean的版本号，通过修改版本号来执行使用哪个版本的bean，设置为*时表示随机使用一个版本（这也表示依赖注入的时候，使用的是按照类型注入）</p>
<h4 id="本地存根对象（stub）"><a href="#本地存根对象（stub）" class="headerlink" title="本地存根对象（stub）"></a>本地存根对象（stub）</h4><p>可以用sub设置本地存根对象，可以设置一个类，里面传入一个UserService类型的参数作为构造器,构造器必须是public</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceStub</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line"></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceStub</span><span class="params">(UserService userService)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.userService=userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">selectUsersById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进来&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> userService.selectUsersById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于对dubbo容器中的远程对象进行动态代理，构造器中传入的userService对象是远程的代理对象，指定一个bean的sub为UserServiceSub后，或调用UserServiceSub中的方法，然后在UserServiceSub类的方法中调用远程对象的方法，进行RPC，相当于进行了动态代理</p>
<p>使用时指定stub类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference(stub = &quot;com.lth.service.UserServiceStub&quot;)</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getUsersById</span><span class="params">(<span class="meta">@RequestParam(&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.selectUsersById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Dubbo和Springboot整合的配置"><a href="#Dubbo和Springboot整合的配置" class="headerlink" title="Dubbo和Springboot整合的配置"></a>Dubbo和Springboot整合的配置</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/8e1bfff67d8e682a9f8c1cde13d8f3db.png" alt="image-20220603233246841"></p>
<p>上面讲述的都是在xml中进行配置的方法，而在和springboot整合的时候也是完全适用的</p>
<p>消费者的全局配置参数在application.properties中配置</p>
<p>而精确配置在注解@Reference的参数中</p>
<p>服务提供者的全局配置也是在application.properties中配置</p>
<p>而精确配置在@Service的参数中</p>
<p>整合的三种方式：</p>
<ol>
<li>导入dubbo的starter，在application.properties中设置配置参数，用@Service暴露接口，用@Reference调用接口（并配置参数），并加上@EnableDubbo来扫描带有dubbo注解的类，如果在properties中设置包扫描路径则就不需要@EnableDubbo注解</li>
<li>保留dubbo的xml配置文件，在spring的配置类中用@ImportResource(“/provider.xml”)来加载配置文件，也能达到相同的效果，这样就可以代理注解（显然注解更方便）</li>
<li>每一个xml元素，properties配置项在spring容器中都会对应一个配置类，我们也可以将需要的配置类（@Configuration）注入到spring容器中，这样也可以完成我们想要的功能，用xxxConfig类的对象代替xml标签中的xxx</li>
</ol>
<p>第三种方式我们可以举个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDubboConfig</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> ApplicationConfig <span class="title function_">applicationConfig</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">ApplicationConfig</span> <span class="variable">applicationConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationConfig</span>();</span><br><span class="line">		applicationConfig.setName(<span class="string">&quot;boot-user-service-provider&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> applicationConfig;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//&lt;dubbo:registry protocol=&quot;zookeeper&quot; address=&quot;127.0.0.1:2181&quot;&gt;&lt;/dubbo:registry&gt;</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> RegistryConfig <span class="title function_">registryConfig</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">RegistryConfig</span> <span class="variable">registryConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegistryConfig</span>();</span><br><span class="line">		registryConfig.setProtocol(<span class="string">&quot;zookeeper&quot;</span>);</span><br><span class="line">		registryConfig.setAddress(<span class="string">&quot;127.0.0.1:2181&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> registryConfig;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20882&quot;&gt;&lt;/dubbo:protocol&gt;</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> ProtocolConfig <span class="title function_">protocolConfig</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">ProtocolConfig</span> <span class="variable">protocolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProtocolConfig</span>();</span><br><span class="line">		protocolConfig.setName(<span class="string">&quot;dubbo&quot;</span>);</span><br><span class="line">		protocolConfig.setPort(<span class="number">20882</span>);</span><br><span class="line">		<span class="keyword">return</span> protocolConfig;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *&lt;dubbo:service interface=&quot;com.atguigu.gmall.service.UserService&quot; </span></span><br><span class="line"><span class="comment">		ref=&quot;userServiceImpl01&quot; timeout=&quot;1000&quot; version=&quot;1.0.0&quot;&gt;</span></span><br><span class="line"><span class="comment">		&lt;dubbo:method name=&quot;getUserAddressList&quot; timeout=&quot;1000&quot;&gt;&lt;/dubbo:method&gt;</span></span><br><span class="line"><span class="comment">	&lt;/dubbo:service&gt;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> ServiceConfig&lt;UserService&gt; <span class="title function_">userServiceConfig</span><span class="params">(UserService userService)</span>&#123;</span><br><span class="line">		ServiceConfig&lt;UserService&gt; serviceConfig = <span class="keyword">new</span> <span class="title class_">ServiceConfig</span>&lt;&gt;();</span><br><span class="line">		serviceConfig.setInterface(UserService.class);</span><br><span class="line">		serviceConfig.setRef(userService);</span><br><span class="line">		serviceConfig.setVersion(<span class="string">&quot;1.0.0&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//配置每一个method的信息</span></span><br><span class="line">		<span class="type">MethodConfig</span> <span class="variable">methodConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodConfig</span>();</span><br><span class="line">		methodConfig.setName(<span class="string">&quot;getUserAddressList&quot;</span>);</span><br><span class="line">		methodConfig.setTimeout(<span class="number">1000</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将method的设置关联到service配置中</span></span><br><span class="line">		List&lt;MethodConfig&gt; methods = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		methods.add(methodConfig);</span><br><span class="line">		serviceConfig.setMethods(methods);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//ProviderConfig</span></span><br><span class="line">		<span class="comment">//MonitorConfig</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> serviceConfig;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="高可用Dubbo"><a href="#高可用Dubbo" class="headerlink" title="高可用Dubbo"></a>高可用Dubbo</h2><h3 id="Zookeeper宕机和Dubbo直连"><a href="#Zookeeper宕机和Dubbo直连" class="headerlink" title="Zookeeper宕机和Dubbo直连"></a>Zookeeper宕机和Dubbo直连</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/f07f308730ad586f1a64184da62b2c34.png" alt="image-20220604120243072"></p>
<p>注册中心起到的是服务注册和发现的功能，保存有各个服务器的Socket（ip和端口），服务器在通讯之前从注册中心中获取想要通讯的服务器的Socket，然后建立起Socket连接进行通讯，如果注册中心宕机了，服务消费者本地会换成原先调用过的服务提供者的Socket，因而不需要再从注册中心拉取服务列表，查询Socket，而可以直接通讯。我们也可以在@Reference注解的url参数直接指定要通讯的Socket（ip和端口），这样就可以绕开注册中心进行直连</p>
<h3 id="Dubbo负载均衡"><a href="#Dubbo负载均衡" class="headerlink" title="Dubbo负载均衡"></a>Dubbo负载均衡</h3><h4 id="基于权重的随机策略"><a href="#基于权重的随机策略" class="headerlink" title="基于权重的随机策略"></a>基于权重的随机策略</h4><p>Random LoadBalance</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a57d57a0e13cb73efa588c4272ee8af1.png" alt="image-20220604122544120"></p>
<p>根据权重，设计各个服务的概率，然后随机访问</p>
<h4 id="基于权重的轮询策略"><a href="#基于权重的轮询策略" class="headerlink" title="基于权重的轮询策略"></a>基于权重的轮询策略</h4><p>RoundRobin LoadBalance</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-aGBl0iIr-1657813726371)(<a target="_blank" rel="noopener" href="https://s2.loli.net/2022/06/04/nHWbga2SvKYuxIU.png)]">https://s2.loli.net/2022/06/04/nHWbga2SvKYuxIU.png)]</a></p>
<p>基于权重，设计每个周期中服务器的访问顺序</p>
<h4 id="最小活跃数"><a href="#最小活跃数" class="headerlink" title="最小活跃数"></a>最小活跃数</h4><p>LeastActive LoadBalance</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ebed4e6829af25a0348af63d3c4cd0b8.png" alt="image-20220604122851167"></p>
<p>每次请求，总是访问上一次请求耗时最短的服务器</p>
<h4 id="一致性Hash"><a href="#一致性Hash" class="headerlink" title="一致性Hash"></a>一致性Hash</h4><p>ConsistentHash LoadBalance</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9b45062986f034a01041590543642c46.png" alt="image-20220604122929517"></p>
<p>根据URL和参数计算hash值，根据hash值来决定访问哪个服务器，如果一直访问一个url携带相同的参数则会一直访问同一个服务器</p>
<p>使用负载均衡时需要去掉Dubbo直连，否则会绕过注册中心达不到负载均衡的效果</p>
<h4 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h4><p>Dubbo默认采用随机策略，内部有这些类对应不同的策略</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ec8797a43571bf74526d4f4d332f4c27.png" alt="image-20220604132555791"></p>
<p>在@Reference注解的loadbalance参数中设置策略（在其余两种方式也有对应的方式比如在<code>&lt;dubbo:service&gt;</code>标签中设置这个参数）</p>
<p>可以在@Service标签中设置weight（权重），也可以在dubbo的控制台动态地调整</p>
<p>当一个服务器性能不佳时可以降低其权重来控制访问量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Reference(loadbalance = &quot;random&quot;)</span><br><span class="line">UserService userService;</span><br></pre></td></tr></table></figure>

<p>可以选择的值有random,roundrobin,leastactive</p>
<h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/41bb9ab61c95cc66232dd6d77e2465d4.png" alt="image-20220604134744824"></p>
<p>在服务器压力很大的时候，我们可以牺牲一下不重要的业务来保证我们的核心业务正常运行</p>
<p>两种策略：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b2db045aea8214e097eed8fa52a0b7c7.png" alt="image-20220604135010734"></p>
<p>第一种是直接不允许调用，用于不重要的服务不可用的时候</p>
<p>第二种是在调用失败的时候返回空值，用于服务能用但是不稳定的情况，比如超时后，服务就会终止，但如果这不是重要的服务，我们可以让他不抛出异常而是返回空值，这样请求的流程就可以继续进行，完成我们的核心业务</p>
<p>我们可以直接在web控制台来设置策略<a target="_blank" rel="noopener" href="http://localhost:7001/">Dubbo Admin</a></p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-8UbxFDZf-1657813726374)(C:/Users/%E9%BB%8E%E6%98%8E%E7%BB%88%E7%82%B9x/AppData/Roaming/Typora/typora-user-images/image-20220604135749535.png)]</p>
<p>这样运维起来据很方便</p>
<p>屏蔽：调用时直接返回空</p>
<p>容错：调用失败返回空</p>
<p>静止：调用时会直接抛出异常</p>
<h3 id="服务容错方式"><a href="#服务容错方式" class="headerlink" title="服务容错方式"></a>服务容错方式</h3><p>可以在cluster属性设置容错策略</p>
<h4 id="自动切换（failover）"><a href="#自动切换（failover）" class="headerlink" title="自动切换（failover）"></a>自动切换（failover）</h4><p>当出现请求失败时，重试其他服务器，默认的失败策略，可以用retries设置失败次数，通常用于读操作</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/43c9a0b31535f7049ddc351bfff48df9.png" alt="image-20220604152349998"></p>
<h4 id="快速失败-failfast"><a href="#快速失败-failfast" class="headerlink" title="快速失败 failfast"></a>快速失败 failfast</h4><p>只请求一次，失败后立即报错，通常用于写操作</p>
<h4 id="失败安全-failSafe"><a href="#失败安全-failSafe" class="headerlink" title="失败安全 failSafe"></a>失败安全 failSafe</h4><p>失败后直接忽略，通常用于写日志</p>
<h4 id="失败重试-fallback"><a href="#失败重试-fallback" class="headerlink" title="失败重试 fallback"></a>失败重试 fallback</h4><p>失败后定时重试，通常用于消息通知（拉取消息）</p>
<h4 id="并行调度-forking"><a href="#并行调度-forking" class="headerlink" title="并行调度 forking"></a>并行调度 forking</h4><p>一次请求多个服务器，使用forks来设置并行数，有一个成功就算成功，适用于实时性要求很高的场景</p>
<h4 id="广播调度-broadcast"><a href="#广播调度-broadcast" class="headerlink" title="广播调度 broadcast"></a>广播调度 broadcast</h4><p>一次请求各个服务器，有一个失败本次请求就算失败报错，用于提醒所有的服务器更新缓存和日志之类的信息，进行一些同步操作</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f035bec86009c33287dcc6592d01f395.png" alt="image-20220604153523384"></p>
<p>这两种配置其实是等价的，都是设置注册中心中具体的服务</p>
<h3 id="使用Hystrix进行服务容错"><a href="#使用Hystrix进行服务容错" class="headerlink" title="使用Hystrix进行服务容错"></a>使用Hystrix进行服务容错</h3><h4 id="依赖导入"><a href="#依赖导入" class="headerlink" title="依赖导入"></a>依赖导入</h4><p>引入SpringCloud的hystrix进行服务容错</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>还要加上dependencyManagement用于版本管理</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.SR1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在启动类需要加上@EnableHystrix注解，导入Hystrix的组件（服务提供者和消费者都需要加上）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDubbo</span></span><br><span class="line"><span class="meta">@EnableHystrix</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceProviderApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ServiceProviderApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="服务提供者-1"><a href="#服务提供者-1" class="headerlink" title="服务提供者"></a>服务提供者</h4><p>可以存在服务提供者进行容错</p>
<p>在需要被服务容错的方法上加上@HystrixCommand即可，加上注解后这个方法就会被hystrix代理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;selectUsersByIdFallback&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">selectUsersById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进来了………………&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(Math.random()&lt;<span class="number">0.5</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;???&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;lth&quot;</span>,<span class="string">&quot;2001-8-28&quot;</span>,<span class="string">&quot;hubei&quot;</span>,<span class="number">20</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zech&quot;</span>,<span class="string">&quot;2002-8-8&quot;</span>,<span class="string">&quot;hubei&quot;</span>,<span class="number">20</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">selectUsersByIdFallback</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">User</span>()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="服务消费者-1"><a href="#服务消费者-1" class="headerlink" title="服务消费者"></a>服务消费者</h4><p>也可以在服务消费者进行容错</p>
<p>在需要服务容错的方法上@HystrixCommand，表示被hystrix代理，同时可以设置fallbackMethod回调方法在方法出现时自动调用我们设置的方法（其实就相当于try-catch）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;hello&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">selectUsersById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正常执行&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> userService.selectUsersById(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">hello</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;出错啦&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">User</span>()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@HystrixCommand其实就算在服务错误时自动使用回调方法，和try-catch的作用类型，服务提供者和服务消费者并不都需要加上@HystrixCommand注解，在需要出错回调的时候加上这个注解即可，相当于进行了动态代理，并不需要区分服务提供者和服务消费者，在使用这个注解的时候需要在启动类开启@EnableHystrix，这样注解才会生效</p>
<p>并且设置的回调方法，除了方法名以外，要和原来的方法完全一样（参数，返回值），否则会启动报错</p>
<p>带有Spring注解的方法也能进行服务容错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;getUsersByIdFallback&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getUsersById</span><span class="params">(<span class="meta">@RequestParam(&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">2</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;小错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userService.selectUsersById(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getUsersByIdFallback</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;出错啦&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;userService.selectUsersById(id)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在调用目标方法前，将方法的参数保存下来，在调用回调方法时，会根据方法名，反射找到对应的方法，然后将之前保存的参数，按照原来的顺序传递进去，然后执行。其实就是动态代理，用aop很容易实现类似的功能。</p>
<h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2><h3 id="RPC原理"><a href="#RPC原理" class="headerlink" title="RPC原理"></a>RPC原理</h3><p>RPC框架的通用原理</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/45aa41e6829fe06cbc413fc5d1294c7c.png" alt="image-20220604185255544"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/3a63b2fd3d3b3dd6445db5de464df198.png" alt="image-20220604185555662"></p>
<h4 id="通信原理：Netty"><a href="#通信原理：Netty" class="headerlink" title="通信原理：Netty"></a>通信原理：Netty</h4><p>Netty框架极大简化了TCP和UDP网络编程的难度</p>
<p>BIO：阻塞IO，在IO完成之前，线程不会释放，等待IO完成后才能释放</p>
<p>NIO：非阻塞IO</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/90dff32874e123b86a0b9670cf67af11.png" alt="image-20220604190051812"></p>
<p>监听各个IO事件，等某个IO事件完成后，再去通知服务器开启线程来处理</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ixrphDId-1657813726376)(C:/Users/%E9%BB%8E%E6%98%8E%E7%BB%88%E7%82%B9x/AppData/Roaming/Typora/typora-user-images/image-20220604190215009.png)]</p>
<p>Accept表示通道准备就绪</p>
<p>通道连接完成后需要进行一些准备，准备完成后就进入了Accept状态</p>
<p>这里的Channel在Linux中叫做文件句柄fd，在java中叫channel通道，都指的是的IO事件，包括本地磁盘IO和网络IO，都是以输入输出流进行交互</p>
<p>Netty原理</p>
<p><img src="https://img-blog.csdnimg.cn/20200613171217369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTU3NTg4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>Netty主线程组会监听我们指定的Socket（比如Dubbo服务提供者暴露给外部的端口）（每个主线线程监听一个Socket），当有请求发过来时，会先建立TCP连接，然后进入Connect状态，连接建立后需要框架进行一些处理，比如对IO流进行一些封装和初始化操作，这些操作都完成后向主线程发送一个Accept事件，主线程使用多路复用器来监听Accept事件（有请求过来，channel初始化完成后会产生accept事件），当有读事件和写事件出现时，主线程不会阻塞住，而是将其放入一个队列中，然后继续往下处理，直到这个被读的变量被使用才会阻塞住，等待IO事件完成，这也就是异步IO。完成IO事件的是工作线程，出现这些读写事件时，主线程会将channel（需要读写的IO流）和需要处理的事件放入对应Channel的等待队列中，这个队列由多路复用器来维护。当指定channel准备好后，完成IO事件，然后就可以关闭channel，主线程继续向下执行，遇到新的IO事件后继续由工作线程来处理。主线程用于完成请求，工作线程用于完成请求中的IO操作。</p>
<h3 id="Dubbo原理"><a href="#Dubbo原理" class="headerlink" title="Dubbo原理"></a>Dubbo原理</h3><h4 id="框架原理"><a href="#框架原理" class="headerlink" title="框架原理"></a>框架原理</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/8565f8f4bc57a0f8d3f8058d9cee52a4.png" alt="image-20220604205446611"></p>
<h5 id="第一层-业务逻辑层"><a href="#第一层-业务逻辑层" class="headerlink" title="第一层 业务逻辑层"></a>第一层 业务逻辑层</h5><p>因为是面向接口编程，我们是需要编写公共的接口，然后编写他的实现类并暴露给Dubbo即可，框架给我们的只有这一层，剩下的都被框架封装了起来</p>
<h5 id="配置层"><a href="#配置层" class="headerlink" title="配置层"></a>配置层</h5><p>读取配置文件，设置相关属性</p>
<h5 id="代理层"><a href="#代理层" class="headerlink" title="代理层"></a>代理层</h5><p>生成代理对象</p>
<h5 id="注册中心层"><a href="#注册中心层" class="headerlink" title="注册中心层"></a>注册中心层</h5><p>为服务消费者订阅注册中心中需要的服务，同时负责服务的注册与发现，和服务调用的复杂均衡</p>
<h5 id="监控层"><a href="#监控层" class="headerlink" title="监控层"></a>监控层</h5><p>调用服务时会给监控层发送数据</p>
<h5 id="协议层"><a href="#协议层" class="headerlink" title="协议层"></a>协议层</h5><p>完成远程调用RPC</p>
<h5 id="交换层"><a href="#交换层" class="headerlink" title="交换层"></a>交换层</h5><p>服务端和客户端交换数据</p>
<h5 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h5><p>Netty框架工作</p>
<h5 id="序列化层"><a href="#序列化层" class="headerlink" title="序列化层"></a>序列化层</h5><p>将参数和要调用的服务以及调用结果序列化后返回</p>
<p>每一层再Dubbo中都被写在一个包中，每一层都是单向依赖</p>
<h3 id="标签解析"><a href="#标签解析" class="headerlink" title="标签解析"></a>标签解析</h3><p>所有的标签（注解）解析器都会实现一个顶层接口：BeanDefinitionParser</p>
<p>Dubbo实现了这个接口得到的自己的解析器DubboBeanDefinitionParser</p>
<p>解析器可以解析xml标签和dubbo注解</p>
<p>不同的类型的标签由不同的解析规则</p>
<p>每一个标签由对应不同的配置类XxxProperties有两个特例</p>
<p>Service-&gt;ServiceBean</p>
<p>Reference-&gt;ReferenceBean</p>
<p>标签解析器的目的是将标签解析出来，保存在配置类中</p>
<h3 id="服务暴露"><a href="#服务暴露" class="headerlink" title="服务暴露"></a>服务暴露</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/e44883fcec0ad3bb40992bf3010e49d2.png" alt="image-20220604224638440"></p>
<p>ServiceBean实现下面这些接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServiceBean&lt;T&gt; extends ServiceConfig&lt;T&gt; implements InitializingBean, DisposableBean, ApplicationContextAware, ApplicationListener&lt;ContextRefreshedEvent&gt;, BeanNameAware</span><br></pre></td></tr></table></figure>

<p>Spring在调用构造器创建Bean示例后会进行一系列初始化方法</p>
<h4 id="保存配置"><a href="#保存配置" class="headerlink" title="保存配置"></a>保存配置</h4><p>InitializingBean接口：里面有afterPropertiesSet方法，spring在创建属性赋值完后调用这个方法,回顾一下Bean的初始化流程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">构造方法</span><br><span class="line">postProcessBeforeInitialization:user</span><br><span class="line">PostConstruct</span><br><span class="line">xxxAware	此时以及完成了依赖注入</span><br><span class="line">afterPropertiesSet	</span><br><span class="line">methodInit</span><br><span class="line">postProcessAfterInitialization:user</span><br><span class="line">使用bean</span><br><span class="line">preDestroy</span><br><span class="line">destroy</span><br><span class="line">methodDestroy</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">User被创建，调用了构造器</span><br><span class="line">宠物被创建</span><br><span class="line">拿到Bean的名字：user，此时bean的状态：User(name=null, pet=Pet(name=null, description=null))</span><br><span class="line">调用afterPropertiesSet，此时bean的状态：User(name=null, pet=Pet(name=null, description=null))</span><br><span class="line">postProcessBeforeInitialization：User(name=null, pet=Pet(name=null, description=null))</span><br><span class="line">postProcessAfterInitialization：User(name=null, pet=Pet(name=null, description=null))</span><br></pre></td></tr></table></figure>

<p>Dubbo在afterPropertiesSet方法里面将配置文件中的信息保存起来</p>
<h4 id="暴露服务"><a href="#暴露服务" class="headerlink" title="暴露服务"></a>暴露服务</h4><p>ApplicationListener<ContextRefreshedEvent>    每当一个事件发生时（Spring容器启动的一个阶段完成后），会调用这个方法，调用这个方法的时候，spring容器中的组件就全部创建完成了，开始用这些组件干一些特定场景的事情</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ServletWebServerInitializedEvent	</span><br><span class="line"></span><br><span class="line">ContextRefreshedEvent</span><br><span class="line"></span><br><span class="line">ApplicationStartedEvent</span><br><span class="line"></span><br><span class="line">AvailabilityChangeEvent</span><br><span class="line"></span><br><span class="line">ApplicationReadyEvent</span><br><span class="line"></span><br><span class="line">AvailabilityChangeEvent</span><br></pre></td></tr></table></figure>

<p>Dubbo也实现了这个接口，在特定事件发生后完成自己想要的功能</p>
<p>Dubbo在这里，如果服务还没有被暴露，并且需要保留暴露服务给Dubbo（此时IOC容器以及初始化完成，组件都加载进了Spring容器）</p>
<p>暴露的方法是将IP，端口拼接成一个url：registery:127.0.0.1:2811然后添加上url参数表示服务的各种信息，比如服务名称，服务实现的接口，实现类等</p>
<p>我们当前使用的是dubbo，所以会进入dubbo协议保留服务，将要保留的执行者，注册中心的对象url传入暴露给注册中心的方法中注册服务，然后封装成一个exporter暴露器，传给交换层</p>
<p>然后交换层调用openServer，开启Netty服务器，监听这个url，这样暴露就完成了，最后会将暴露完成的url和对于执行器的映射关系保存在本地的一个map里面</p>
<p>这样服务消费者调用这个服务时，只需要想办法获取这个服务的url，然后向服务提供者发送请求（dubbo协议），服务提供者收到请求后从map里面找到对应的执行器，然后执行方法，获取返回值即可</p>
<h3 id="服务引用"><a href="#服务引用" class="headerlink" title="服务引用"></a>服务引用</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/2b5d7d1815afa07b018f5ecf0fd9f03a.png" alt="image-20220605003341776"></p>
<p>ReferenceBean继承了这些接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReferenceBean&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ReferenceConfig</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>, ApplicationContextAware, InitializingBean, DisposableBean</span><br></pre></td></tr></table></figure>

<p>它是一个工厂Bean</p>
<p>我们回顾一下工厂bean的特点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserBeanFactory</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;User&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;lth&quot;</span>,<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> User.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当视图从Spring容器中获取这个工厂bean的时候，获取到的是它getObject()得到的bean，并且如果isSingleton返回true，第二次调用会直接从spring容器中获取第一次调用getObject()拿到的bean，想拿到工厂bean本身需要在bean的id前加上$</p>
<p>Dubbo也是使用的这个机制</p>
<p>在用@Autowire获取Bean的时候或调用这个工厂bean的getObject方法，方法里面如果没有这个对象则创建这个对象，这个对象本质上是一个代理对象，在设置完一些属性后，将配置的一些参数传入方法中创建代理对象，通过接口进行RPC，想要进行RPC就要使用dubbo协议，先根据url的地址拿到注册中心的信息，然后从注册中心获取查询参数拼接到url里面，然后在注册中心里订阅服务提供者提供的服务（当服务提供者上线对象的服务后，服务消费者就会得到对应的服务的Socket，这样就能通过url调用服务）</p>
<p>获取Dubbo客户端，拿到url地址，调用Netty进行RPC，创建连接，将连接封装成一个invoker返回，并放入一个map里面（本地缓存），代理对象里面直接调用这个invoker来完成功能</p>
<h3 id="服务调用的流程"><a href="#服务调用的流程" class="headerlink" title="服务调用的流程"></a>服务调用的流程</h3><p><img src="https://img-blog.csdnimg.cn/20200613171806762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTU3NTg4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>先来到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InvokerInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Invoker&lt;?&gt; invoker;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InvokerInvocationHandler</span><span class="params">(Invoker&lt;?&gt; handler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.invoker = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getName();</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">        <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(invoker, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;toString&quot;</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;hashCode&quot;</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;equals&quot;</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.equals(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> invoker.invoke(<span class="keyword">new</span> <span class="title class_">RpcInvocation</span>(method, args)).recreate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>invoker是我们层层封装的执行者，里面含有需要请求的URL和相关的配置信息</p>
<p>然后拿到代理对象（失败重试策略的对象），根据缓存的url连接客户端，将数据和配置参数也收集其他，调用Netty框架发送请求，得到返回结果</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Dubbo是一个简易高效的RPC框架，采用二进制传输的方式效率很高，可以帮助我们解决分布式系统中的一些问题，但是它的能力还是有限的，SpringCloud为分布式系统系统了一套完整的解决方案，Dubbo可以为学习SpringCoud打下基础。但其实我们个人感觉，使用起来Dubbo要比SpringCloud容易很多，服务调用起来也十分方便就像是一个公共的IOC容器。Dubbo和SpringCloud目前也可以进行融合（毕竟都是spring家的东西嘛），Dubbo最大的优点就算性能好，采用的是Netty框架下的TCP长连接而不是Http协议，这样的好处是RPC的效率很高，但是和其他的一些HTTP协议的框架兼容性可能不太好，而SpringCloud采用的是HTTP协议，并且是将功能作为一个服务，好处是可以和其他的一些基于HTTP框架兼容，并且对分布式系统的各种问题都有完整的解决方案，缺点就是性能欠佳，如果对性能要求高的话，使用Dubbo，如果系统比较复杂，需要强大的运维和错误处理能力用SpringCloud即可。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://thgg.github.io/2022/11/30/Dubbo/" data-id="clb3n4wyt0001d8wwa9uwacr7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/11/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          设计模式
        
      </div>
    </a>
  
  
    <a href="/2022/11/30/Springboot-%E4%B8%8B%E7%AF%87/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Springboot(下篇)</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/11/30/Springboot%E6%B3%A8%E8%A7%A3/">Springboot注解</a>
          </li>
        
          <li>
            <a href="/2022/11/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
          </li>
        
          <li>
            <a href="/2022/11/30/Dubbo/">Dubbo</a>
          </li>
        
          <li>
            <a href="/2022/11/30/Springboot-%E4%B8%8B%E7%AF%87/">Springboot(下篇)</a>
          </li>
        
          <li>
            <a href="/2022/11/30/Springboot-%E4%B8%8A%E7%AF%87/">Springboot(上篇)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 LTH<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>